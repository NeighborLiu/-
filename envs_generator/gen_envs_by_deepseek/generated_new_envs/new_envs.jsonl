{"name": "search_papers", "description": "Search for academic papers on arXiv based on specified criteria.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to find relevant papers."}, "max_results": {"type": "integer", "description": "The maximum number of results to return.", "minimum": 1, "maximum": 1000}, "sort_by": {"type": "string", "description": "The sorting criteria for the search results. Options: 'relevance', 'lastUpdatedDate', 'submittedDate'.", "enum": ["relevance", "lastUpdatedDate", "submittedDate"]}, "sort_order": {"type": "string", "description": "The order of sorting. Options: 'ascending', 'descending'.", "enum": ["ascending", "descending"]}, "categories": {"type": "array", "description": "The arXiv categories to filter the search results.", "items": {"type": "string", "description": "An arXiv category, e.g., 'cs.AI', 'math.OC'."}}, "start_date": {"type": "string", "description": "The start date for filtering papers (format: YYYY-MM-DD)."}, "end_date": {"type": "string", "description": "The end date for filtering papers (format: YYYY-MM-DD)."}}, "required": ["query"]}, "toolkit_name": "ArxivToolkit"}
{"name": "download_paper", "description": "Download an academic paper from arXiv based on its unique identifier.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The unique identifier of the paper to download, typically in the format 'arXiv:1234.5678' or '1234.5678'."}, "download_path": {"type": "string", "description": "The local path where the downloaded paper will be saved."}, "format": {"type": "string", "description": "The desired format of the downloaded paper (e.g., 'pdf', 'ps', 'src'). Default is 'pdf'.", "default": "pdf"}}, "required": ["paper_id", "download_path"]}, "toolkit_name": "ArxivToolkit"}
{"name": "get_paper_details", "description": "Retrieve detailed information about a specific academic paper from arXiv.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The unique identifier of the paper on arXiv (e.g., '1706.03762')."}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract in the returned details. Default is true.", "default": true}, "include_authors": {"type": "boolean", "description": "Whether to include the authors' information in the returned details. Default is true.", "default": true}, "include_categories": {"type": "boolean", "description": "Whether to include the categories (e.g., 'cs.CL') in the returned details. Default is true.", "default": true}}, "required": ["paper_id"]}, "toolkit_name": "ArxivToolkit"}
{"name": "get_citations", "description": "Retrieve the citations of a specific academic paper from arXiv.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The unique identifier of the paper on arXiv."}, "max_results": {"type": "integer", "description": "The maximum number of citations to retrieve.", "minimum": 1, "maximum": 100}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract of each cited paper.", "default": false}}, "required": ["paper_id"]}, "toolkit_name": "ArxivToolkit"}
{"name": "get_author_papers", "description": "Retrieve a list of academic papers authored by a specific researcher from arXiv.", "parameters": {"type": "object", "properties": {"author_name": {"type": "string", "description": "The name of the author to search for."}, "max_results": {"type": "integer", "description": "The maximum number of results to return.", "minimum": 1, "maximum": 1000}, "sort_by": {"type": "string", "description": "The sorting criteria for the results. Options: 'relevance', 'lastUpdatedDate', 'submittedDate'.", "enum": ["relevance", "lastUpdatedDate", "submittedDate"]}, "start": {"type": "integer", "description": "The starting index of the results to return (for pagination).", "minimum": 0}}, "required": ["author_name"]}, "toolkit_name": "ArxivToolkit"}
{"name": "fetch_news", "description": "Fetch news, stories, and other content based on user queries using the AskNews API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to fetch relevant news and stories."}, "max_results": {"type": "integer", "description": "The maximum number of results to return.", "minimum": 1, "maximum": 50}, "language": {"type": "string", "description": "The language of the news content (e.g., 'en' for English, 'es' for Spanish).", "default": "en"}, "date_range": {"type": "string", "description": "The date range for the news (e.g., 'today', 'this_week', 'this_month').", "default": "today"}, "include_sources": {"type": "array", "description": "A list of news sources to include in the results.", "items": {"type": "string", "description": "The name or identifier of a news source."}}, "exclude_sources": {"type": "array", "description": "A list of news sources to exclude from the results.", "items": {"type": "string", "description": "The name or identifier of a news source."}}}, "required": ["query"]}, "toolkit_name": "AskNewsToolkit"}
{"name": "search_news", "description": "Search for news articles, stories, and other content based on user queries using the AskNews API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to find relevant news articles and stories."}, "limit": {"type": "integer", "description": "The maximum number of news articles to return.", "minimum": 1, "maximum": 100}, "language": {"type": "string", "description": "The language of the news articles (e.g., 'en' for English, 'es' for Spanish)."}, "date_range": {"type": "object", "description": "The date range for the news articles.", "properties": {"start_date": {"type": "string", "description": "The start date in YYYY-MM-DD format."}, "end_date": {"type": "string", "description": "The end date in YYYY-MM-DD format."}}}, "sort_by": {"type": "string", "description": "The sorting criteria for the news articles (e.g., 'relevance', 'date').", "enum": ["relevance", "date"]}}, "required": ["query"]}, "toolkit_name": "AskNewsToolkit"}
{"name": "get_trending_news", "description": "Fetch trending news articles based on popularity and current trends.", "parameters": {"type": "object", "properties": {"category": {"type": "string", "description": "The category of trending news to fetch (e.g., sports, technology, politics)."}, "region": {"type": "string", "description": "The region for which trending news should be fetched (e.g., us, uk, global)."}, "limit": {"type": "integer", "description": "The maximum number of trending news articles to fetch."}, "time_range": {"type": "string", "description": "The time range for trending news (e.g., today, this_week, this_month)."}}, "required": []}, "toolkit_name": "AskNewsToolkit"}
{"name": "get_news_by_category", "description": "Fetch news articles based on a specified category using the AskNews API.", "parameters": {"type": "object", "properties": {"category": {"type": "string", "description": "The category of news to fetch (e.g., sports, technology, politics)."}, "limit": {"type": "integer", "description": "The maximum number of news articles to return.", "minimum": 1, "maximum": 100}, "language": {"type": "string", "description": "The language of the news articles (e.g., en, fr, de)."}, "country": {"type": "string", "description": "The country code to filter news articles by (e.g., us, gb, ca)."}}, "required": ["category"]}, "toolkit_name": "AskNewsToolkit"}
{"name": "get_news_by_source", "description": "Fetch news articles from a specific source using the AskNews API.", "parameters": {"type": "object", "properties": {"source": {"type": "string", "description": "The name or identifier of the news source."}, "limit": {"type": "integer", "description": "The maximum number of news articles to fetch.", "minimum": 1, "maximum": 100}, "date_range": {"type": "object", "description": "The date range for the news articles.", "properties": {"start_date": {"type": "string", "format": "date", "description": "The start date for the news articles (YYYY-MM-DD)."}, "end_date": {"type": "string", "format": "date", "description": "The end date for the news articles (YYYY-MM-DD)."}}}, "include_content": {"type": "boolean", "description": "Whether to include the full content of the news articles."}}, "required": ["source"]}, "toolkit_name": "AskNewsToolkit"}
{"name": "analyze_audio_sentiment", "description": "Analyze the sentiment of an audio file to determine the emotional tone of the spoken content.", "parameters": {"type": "object", "properties": {"audio_file_path": {"type": "string", "description": "The local path or URL of the audio file to be analyzed."}, "language": {"type": "string", "description": "The language of the spoken content in the audio file. Default is 'en' (English)."}, "detailed_analysis": {"type": "boolean", "description": "If true, provides a detailed breakdown of sentiment scores (positive, negative, neutral). Default is false."}}, "required": ["audio_file_path"]}, "toolkit_name": "AudioAnalysisToolkit"}
{"name": "transcribe_audio", "description": "Transcribe audio content into text.", "parameters": {"type": "object", "properties": {"audio_file_path": {"type": "string", "description": "The local path or URL of the audio file to be transcribed."}, "language": {"type": "string", "description": "The language of the audio content for accurate transcription."}, "timestamp": {"type": "boolean", "description": "Whether to include timestamps in the transcription output."}, "speaker_diarization": {"type": "boolean", "description": "Whether to identify and separate different speakers in the transcription."}}, "required": ["audio_file_path"]}, "toolkit_name": "AudioAnalysisToolkit"}
{"name": "extract_audio_features", "description": "Extract various features from an audio file such as tempo, pitch, and loudness for analysis.", "parameters": {"type": "object", "properties": {"audio_file_path": {"type": "string", "description": "The local path or URL of the audio file to be analyzed."}, "features": {"type": "array", "description": "The list of features to extract from the audio file.", "items": {"type": "string", "description": "The specific feature to extract (e.g., 'tempo', 'pitch', 'loudness')."}}, "normalize": {"type": "boolean", "description": "Whether to normalize the extracted features."}, "output_format": {"type": "string", "description": "The format of the output (e.g., 'json', 'csv')."}}, "required": ["audio_file_path", "features"]}, "toolkit_name": "AudioAnalysisToolkit"}
{"name": "answer_audio_questions", "description": "Answer questions about the content of an audio file by analyzing its transcription.", "parameters": {"type": "object", "properties": {"audio_file_path": {"type": "string", "description": "The local path or URL of the audio file to be analyzed."}, "questions": {"type": "array", "description": "A list of questions about the audio content.", "items": {"type": "string", "description": "A specific question about the audio content."}}, "language": {"type": "string", "description": "The language of the audio content. Default is 'en' (English)."}, "detailed": {"type": "boolean", "description": "Whether to provide detailed answers with timestamps. Default is false."}}, "required": ["audio_file_path", "questions"]}, "toolkit_name": "AudioAnalysisToolkit"}
{"name": "detect_audio_language", "description": "Detect the language spoken in an audio file.", "parameters": {"type": "object", "properties": {"audio_file_path": {"type": "string", "description": "The local path or URL of the audio file to analyze."}, "confidence_threshold": {"type": "number", "description": "The minimum confidence score (between 0 and 1) required to consider a language detection result valid.", "minimum": 0, "maximum": 1}}, "required": ["audio_file_path"]}, "toolkit_name": "AudioAnalysisToolkit"}
{"name": "extract_web_content", "description": "Extract specific content from a web page, such as text, links, or images.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the web page to extract content from."}, "content_type": {"type": "string", "description": "The type of content to extract (e.g., 'text', 'links', 'images')."}, "selector": {"type": "string", "description": "The CSS selector to locate the specific content on the page."}, "limit": {"type": "integer", "description": "The maximum number of items to extract. If not specified, all matching items will be extracted."}, "include_metadata": {"type": "boolean", "description": "Whether to include metadata (e.g., alt text for images, href for links) with the extracted content."}}, "required": ["url", "content_type"]}, "toolkit_name": "BrowserToolkit"}
{"name": "simulate_browser_action", "description": "Simulate browser actions such as clicking, scrolling, or filling forms on a web page.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the web page to interact with."}, "actions": {"type": "array", "description": "A list of actions to perform on the web page.", "items": {"type": "object", "properties": {"type": {"type": "string", "description": "The type of action to perform (e.g., 'click', 'scroll', 'fill').", "enum": ["click", "scroll", "fill"]}, "selector": {"type": "string", "description": "The CSS selector to identify the element to interact with."}, "value": {"type": "string", "description": "The value to fill in case the action type is 'fill'."}, "scroll_amount": {"type": "integer", "description": "The amount to scroll in pixels, required if action type is 'scroll'."}}, "required": ["type", "selector"]}}, "wait_time": {"type": "integer", "description": "The time in seconds to wait after performing all actions."}}, "required": ["url", "actions"]}, "toolkit_name": "BrowserToolkit"}
{"name": "navigate_to_url", "description": "Navigate the browser to a specified URL and load the web page.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL to navigate to."}, "wait_time": {"type": "integer", "description": "The time in seconds to wait for the page to load completely."}, "interactive": {"type": "boolean", "description": "Whether to simulate human-like interaction during navigation (e.g., random delays)."}}, "required": ["url"]}, "toolkit_name": "BrowserToolkit"}
{"name": "search_web", "description": "Perform a web search using a search engine and retrieve the results.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to be performed."}, "search_engine": {"type": "string", "description": "The search engine to use for the query (e.g., 'google', 'bing', 'yahoo'). Default is 'google'.", "default": "google"}, "max_results": {"type": "integer", "description": "The maximum number of search results to retrieve. Default is 10.", "default": 10}, "include_descriptions": {"type": "boolean", "description": "Whether to include descriptions of the search results. Default is true.", "default": true}}, "required": ["query"]}, "toolkit_name": "BrowserToolkit"}
{"name": "get_page_metadata", "description": "Extract metadata from a web page, including title, description, and keywords.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the web page to extract metadata from."}, "include_og_tags": {"type": "boolean", "description": "Whether to include Open Graph (og) tags in the metadata extraction.", "default": false}, "include_twitter_tags": {"type": "boolean", "description": "Whether to include Twitter card tags in the metadata extraction.", "default": false}}, "required": ["url"]}, "toolkit_name": "BrowserToolkit"}
{"name": "execute_python_code", "description": "Execute Python code in a specified sandbox environment.", "parameters": {"type": "object", "properties": {"code": {"type": "string", "description": "The Python code to be executed."}, "sandbox_type": {"type": "string", "description": "The type of sandbox to execute the code in. Options include 'internal_python', 'jupyter', 'docker', 'subprocess', or 'e2b'.", "enum": ["internal_python", "jupyter", "docker", "subprocess", "e2b"]}, "timeout": {"type": "integer", "description": "The maximum time in seconds allowed for the code execution. Default is 30 seconds.", "default": 30}, "environment_variables": {"type": "object", "description": "A dictionary of environment variables to be set in the sandbox.", "additionalProperties": {"type": "string"}}, "dependencies": {"type": "array", "description": "A list of dependencies required for the code execution.", "items": {"type": "string", "description": "The name of the dependency."}}}, "required": ["code", "sandbox_type"]}, "toolkit_name": "CodeExecutionToolkit"}
{"name": "execute_javascript_code", "description": "Execute JavaScript code in a sandboxed environment.", "parameters": {"type": "object", "properties": {"code": {"type": "string", "description": "The JavaScript code to be executed."}, "sandbox": {"type": "string", "description": "The sandbox environment to run the code in. Options include 'internal', 'Docker', 'subprocess', or 'e2b'.", "enum": ["internal", "Docker", "subprocess", "e2b"]}, "timeout": {"type": "integer", "description": "The maximum execution time in milliseconds before the process is terminated."}, "context": {"type": "object", "description": "Additional context or variables to be passed to the execution environment."}}, "required": ["code"]}, "toolkit_name": "CodeExecutionToolkit"}
{"name": "execute_docker_container", "description": "Execute a code snippet or script inside a Docker container.", "parameters": {"type": "object", "properties": {"image": {"type": "string", "description": "The Docker image to use for the container."}, "command": {"type": "array", "description": "The command to run inside the container.", "items": {"type": "string", "description": "A part of the command to be executed."}}, "environment_variables": {"type": "object", "description": "Environment variables to set in the container.", "additionalProperties": {"type": "string", "description": "The value of the environment variable."}}, "timeout": {"type": "integer", "description": "The maximum time in seconds to allow the container to run before timing out."}, "volumes": {"type": "object", "description": "Volumes to mount inside the container.", "additionalProperties": {"type": "string", "description": "The host path to mount inside the container."}}}, "required": ["image", "command"]}, "toolkit_name": "CodeExecutionToolkit"}
{"name": "execute_jupyter_notebook", "description": "Execute code in a Jupyter notebook environment.", "parameters": {"type": "object", "properties": {"code": {"type": "string", "description": "The code to be executed in the Jupyter notebook."}, "kernel_type": {"type": "string", "description": "The type of kernel to use for execution (e.g., 'python3', 'javascript')."}, "timeout": {"type": "integer", "description": "The maximum time in seconds allowed for the code to execute."}, "output_variables": {"type": "array", "description": "List of variable names to capture from the notebook after execution.", "items": {"type": "string", "description": "The name of the variable to capture."}}}, "required": ["code", "kernel_type"]}, "toolkit_name": "CodeExecutionToolkit"}
{"name": "execute_shell_command", "description": "Execute a shell command in a subprocess sandbox and return the output.", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to be executed."}, "timeout": {"type": "integer", "description": "The maximum time in seconds to wait for the command to complete."}, "working_directory": {"type": "string", "description": "The working directory where the command will be executed."}, "environment_variables": {"type": "object", "description": "A dictionary of environment variables to set for the command execution.", "additionalProperties": {"type": "string", "description": "The value of the environment variable."}}}, "required": ["command"]}, "toolkit_name": "CodeExecutionToolkit"}
{"name": "generate_image", "description": "Generate an image using OpenAI's DALL-E model based on a given prompt.", "parameters": {"type": "object", "properties": {"prompt": {"type": "string", "description": "The text prompt based on which the image will be generated."}, "size": {"type": "string", "description": "The size of the generated image. Options are '256x256', '512x512', or '1024x1024'.", "enum": ["256x256", "512x512", "1024x1024"]}, "num_images": {"type": "integer", "description": "The number of images to generate. Default is 1.", "minimum": 1, "maximum": 10}, "style": {"type": "string", "description": "The style of the generated image. Options are 'vivid' or 'natural'.", "enum": ["vivid", "natural"]}}, "required": ["prompt"]}, "toolkit_name": "DalleToolkit"}
{"name": "generate_image_variations", "description": "Generate variations of an existing image using OpenAI's DALL-E model.", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path of the image to generate variations from."}, "num_variations": {"type": "integer", "description": "The number of variations to generate.", "minimum": 1, "maximum": 10}, "size": {"type": "string", "description": "The size of the generated images. Must be one of ['256x256', '512x512', '1024x1024'].", "enum": ["256x256", "512x512", "1024x1024"]}, "output_format": {"type": "string", "description": "The format of the output images. Must be one of ['url', 'binary'].", "enum": ["url", "binary"]}}, "required": ["image_path", "num_variations"]}, "toolkit_name": "DalleToolkit"}
{"name": "edit_image", "description": "Edit an existing image using OpenAI's DALL-E model by providing a mask and a prompt for the desired changes.", "parameters": {"type": "object", "properties": {"image": {"type": "string", "description": "The base image to be edited, provided as a URL or base64 encoded string."}, "mask": {"type": "string", "description": "The mask image indicating which parts of the base image should be edited, provided as a URL or base64 encoded string."}, "prompt": {"type": "string", "description": "A textual description of the desired changes to the image."}, "n": {"type": "integer", "description": "The number of variations to generate for the edited image.", "minimum": 1, "maximum": 10}, "size": {"type": "string", "description": "The size of the generated images. Must be one of ['256x256', '512x512', '1024x1024'].", "enum": ["256x256", "512x512", "1024x1024"]}}, "required": ["image", "mask", "prompt"]}, "toolkit_name": "DalleToolkit"}
{"name": "upscale_image", "description": "Upscale an image to a higher resolution using OpenAI's DALL-E model.", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path of the image to be upscaled."}, "scale_factor": {"type": "number", "description": "The factor by which the image resolution should be increased (e.g., 2 for doubling the resolution)."}, "output_format": {"type": "string", "description": "The desired format of the upscaled image (e.g., 'png', 'jpeg')."}}, "required": ["image_path", "scale_factor"]}, "toolkit_name": "DalleToolkit"}
{"name": "generate_image_from_text", "description": "Generate an image based on a given text prompt using OpenAI's DALL-E model.", "parameters": {"type": "object", "properties": {"prompt": {"type": "string", "description": "The text prompt to generate the image from."}, "num_images": {"type": "integer", "description": "The number of images to generate.", "minimum": 1, "maximum": 10}, "size": {"type": "string", "description": "The size of the generated image. Options are '256x256', '512x512', or '1024x1024'.", "enum": ["256x256", "512x512", "1024x1024"]}, "output_format": {"type": "string", "description": "The format of the output image. Options are 'url' or 'b64_json'.", "enum": ["url", "b64_json"]}}, "required": ["prompt"]}, "toolkit_name": "DalleToolkit"}
{"name": "fetch_ai_recommendations", "description": "Fetch AI-generated recommendations based on real-time data across key verticals like News, Finance, Stock Market, Sports, Weather, and more.", "parameters": {"type": "object", "properties": {"vertical": {"type": "string", "description": "The vertical for which recommendations are needed (e.g., News, Finance, Stock Market, Sports, Weather)."}, "query": {"type": "string", "description": "The specific query or topic for which AI recommendations are required."}, "max_results": {"type": "integer", "description": "The maximum number of recommendations to fetch."}, "include_details": {"type": "boolean", "description": "Whether to include detailed information for each recommendation."}, "filters": {"type": "object", "description": "Additional filters to apply to the recommendations (e.g., time range, relevance score).", "properties": {"time_range": {"type": "string", "description": "The time range for the recommendations (e.g., '1d', '1w', '1m')."}, "min_relevance": {"type": "number", "description": "The minimum relevance score for the recommendations (0 to 1)."}}}}, "required": ["vertical", "query"]}, "toolkit_name": "DappierToolkit"}
{"name": "search_real_time_data", "description": "Search for real-time data across key verticals such as News, Finance, Stock Market, Sports, Weather, and more using the Dappier API.", "parameters": {"type": "object", "properties": {"vertical": {"type": "string", "description": "The vertical to search for real-time data. Options include News, Finance, Stock Market, Sports, Weather, etc."}, "query": {"type": "string", "description": "The search query to filter the real-time data."}, "limit": {"type": "integer", "description": "The maximum number of results to return."}, "filters": {"type": "object", "description": "Additional filters to apply to the search query.", "properties": {"date_range": {"type": "string", "description": "The date range for the search results (e.g., 'today', 'this_week', 'this_month')."}, "region": {"type": "string", "description": "The region to filter the search results (e.g., 'US', 'EU', 'Asia')."}, "language": {"type": "string", "description": "The language of the search results (e.g., 'en', 'es', 'fr')."}}}}, "required": ["vertical"]}, "toolkit_name": "DappierToolkit"}
{"name": "get_weather_forecast", "description": "Fetch the weather forecast for a specific location using the Dappier API.", "parameters": {"type": "object", "properties": {"location": {"type": "string", "description": "The name of the location for which the weather forecast is required."}, "days": {"type": "integer", "description": "The number of days for which the forecast is needed (default is 1)."}, "units": {"type": "string", "description": "The unit system for the weather data (e.g., 'metric' for Celsius, 'imperial' for Fahrenheit)."}, "include_details": {"type": "boolean", "description": "Whether to include detailed weather information like humidity, wind speed, etc."}}, "required": ["location"]}, "toolkit_name": "DappierToolkit"}
{"name": "get_stock_market_data", "description": "Fetch real-time stock market data for specified symbols, including price, volume, and other relevant metrics.", "parameters": {"type": "object", "properties": {"symbols": {"type": "array", "description": "The stock symbols to fetch data for.", "items": {"type": "string", "description": "A stock symbol, e.g., AAPL for Apple Inc."}}, "metrics": {"type": "array", "description": "Specific metrics to retrieve for the stocks.", "items": {"type": "string", "description": "A metric such as 'price', 'volume', 'market_cap', etc."}}, "time_range": {"type": "string", "description": "The time range for the data, e.g., '1d', '1w', '1m'."}}, "required": ["symbols"]}, "toolkit_name": "DappierToolkit"}
{"name": "get_financial_news", "description": "Fetch the latest financial news and updates from various sources using the Dappier API.", "parameters": {"type": "object", "properties": {"keywords": {"type": "array", "description": "Keywords to search for in financial news articles.", "items": {"type": "string", "description": "A keyword related to financial news."}}, "sources": {"type": "array", "description": "Preferred news sources to fetch articles from.", "items": {"type": "string", "description": "A specific news source."}}, "limit": {"type": "integer", "description": "Maximum number of news articles to fetch.", "minimum": 1, "maximum": 50}, "time_range": {"type": "string", "description": "Time range for the news articles (e.g., '1h', '24h', '7d')."}}, "required": ["keywords"]}, "toolkit_name": "DappierToolkit"}
{"name": "get_statistical_time_series", "description": "Retrieve statistical time series data for a specific variable and geographic location from the Data Commons knowledge graph.", "parameters": {"type": "object", "properties": {"variable": {"type": "string", "description": "The variable for which the time series data is requested (e.g., 'UnemploymentRate', 'Population')."}, "location": {"type": "string", "description": "The geographic location for which the time series data is requested (e.g., 'country/USA', 'geoId/06' for California)."}, "start_date": {"type": "string", "description": "The start date of the time series in 'YYYY-MM-DD' format. If not provided, the earliest available date will be used."}, "end_date": {"type": "string", "description": "The end date of the time series in 'YYYY-MM-DD' format. If not provided, the latest available date will be used."}, "aggregation": {"type": "string", "description": "The aggregation method for the time series data (e.g., 'YEARLY', 'MONTHLY', 'QUARTERLY'). If not provided, raw data will be returned."}}, "required": ["variable", "location"]}, "toolkit_name": "DataCommonsToolkit"}
{"name": "query_property_values", "description": "Query property values of a specific entity from the Data Commons knowledge graph.", "parameters": {"type": "object", "properties": {"entity_id": {"type": "string", "description": "The unique identifier of the entity in the Data Commons knowledge graph."}, "property": {"type": "string", "description": "The property of the entity whose values are to be queried."}, "limit": {"type": "integer", "description": "The maximum number of property values to return.", "default": 10}, "filter": {"type": "object", "description": "Optional filters to apply on the property values.", "properties": {"type": {"type": "string", "description": "The type of filter to apply (e.g., 'equals', 'contains')."}, "value": {"type": "string", "description": "The value to filter by."}}}}, "required": ["entity_id", "property"]}, "toolkit_name": "DataCommonsToolkit"}
{"name": "execute_sparql_query", "description": "Execute a SPARQL query on the Data Commons knowledge graph to retrieve structured data.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The SPARQL query string to be executed."}, "format": {"type": "string", "description": "The format of the query results, e.g., 'json', 'csv'.", "default": "json"}, "limit": {"type": "integer", "description": "The maximum number of results to return.", "default": 100}, "offset": {"type": "integer", "description": "The number of results to skip before starting to return results.", "default": 0}}, "required": ["query"]}, "toolkit_name": "DataCommonsToolkit"}
{"name": "get_place_statistics", "description": "Retrieve statistical data for a specific place from the Data Commons knowledge graph, such as population, area, or other demographic information.", "parameters": {"type": "object", "properties": {"place_id": {"type": "string", "description": "The Data Commons ID of the place for which statistics are to be retrieved."}, "statistical_variables": {"type": "array", "description": "The list of statistical variables to retrieve for the specified place.", "items": {"type": "string", "description": "The statistical variable to retrieve, e.g., 'population', 'area', 'medianIncome'."}}, "date": {"type": "string", "description": "The date for which the statistics should be retrieved, in YYYY-MM-DD format. If not specified, the latest available data will be returned."}, "measurement_method": {"type": "string", "description": "The method used to measure the statistical variable, if applicable."}, "observation_period": {"type": "string", "description": "The period over which the observation was made, e.g., 'P1Y' for one year."}}, "required": ["place_id", "statistical_variables"]}, "toolkit_name": "DataCommonsToolkit"}
{"name": "get_place_comparison", "description": "Compare statistical data between two or more places based on specified variables.", "parameters": {"type": "object", "properties": {"place_ids": {"type": "array", "description": "The list of Data Commons place IDs to compare.", "items": {"type": "string", "description": "The Data Commons ID of the place."}}, "statistical_variables": {"type": "array", "description": "The list of statistical variables to compare across the places.", "items": {"type": "string", "description": "The ID of the statistical variable."}}, "date": {"type": "string", "description": "The specific date or time period for the comparison (e.g., '2020', '2015-2020')."}, "measurement_method": {"type": "string", "description": "The method used to measure the statistical variables (optional)."}, "unit": {"type": "string", "description": "The unit of measurement for the statistical variables (optional)."}}, "required": ["place_ids", "statistical_variables"]}, "toolkit_name": "DataCommonsToolkit"}
{"name": "excel_to_markdown", "description": "Convert an Excel file to a markdown table format.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The local path of the Excel file to be converted."}, "sheet_name": {"type": "string", "description": "The name of the sheet within the Excel file to convert. If not specified, the first sheet will be used."}, "include_headers": {"type": "boolean", "description": "Whether to include headers in the markdown table. Default is true."}, "alignment": {"type": "string", "description": "The alignment of the columns in the markdown table. Options are 'left', 'center', 'right'. Default is 'left'.", "enum": ["left", "center", "right"]}}, "required": ["file_path"]}, "toolkit_name": "ExcelToolkit"}
{"name": "extract_excel_sheet", "description": "Extract data from a specific sheet in an Excel file and return it in a structured format.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The local path to the Excel file."}, "sheet_name": {"type": "string", "description": "The name of the sheet to extract data from."}, "include_headers": {"type": "boolean", "description": "Whether to include headers in the extracted data. Default is true.", "default": true}, "range": {"type": "string", "description": "The specific range of cells to extract (e.g., 'A1:D10'). If not specified, the entire sheet is extracted."}}, "required": ["file_path", "sheet_name"]}, "toolkit_name": "ExcelToolkit"}
{"name": "filter_excel_data", "description": "Filter data from an Excel file based on specified criteria and return the filtered results.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The local path of the Excel file to be processed."}, "sheet_name": {"type": "string", "description": "The name of the sheet within the Excel file to filter data from."}, "criteria": {"type": "object", "description": "The filtering criteria to apply to the data. Keys are column names and values are the conditions to match.", "properties": {"column_name": {"type": "string", "description": "The name of the column to apply the filter on."}, "condition": {"type": "string", "description": "The condition to apply (e.g., 'equals', 'contains', 'greater_than')."}, "value": {"type": "string", "description": "The value to compare against for the condition."}}}, "output_format": {"type": "string", "description": "The format of the output data. Options are 'json' or 'markdown'.", "enum": ["json", "markdown"]}}, "required": ["file_path", "sheet_name", "criteria"]}, "toolkit_name": "ExcelToolkit"}
{"name": "merge_excel_sheets", "description": "Merge multiple sheets from an Excel file into a single sheet or a new Excel file.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The local path of the Excel file."}, "sheet_names": {"type": "array", "description": "The names of the sheets to be merged.", "items": {"type": "string", "description": "The name of the sheet."}}, "output_path": {"type": "string", "description": "The local path where the merged Excel file will be saved. If not provided, the merged data will be returned as a JSON object."}, "overwrite": {"type": "boolean", "description": "Whether to overwrite the output file if it already exists. Default is false."}}, "required": ["file_path", "sheet_names"]}, "toolkit_name": "ExcelToolkit"}
{"name": "convert_excel_to_json", "description": "Convert the content of an Excel file into a JSON format for easier data manipulation and processing.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The local path to the Excel file to be converted."}, "sheet_name": {"type": "string", "description": "The name of the specific sheet to convert. If not provided, the first sheet will be used."}, "include_headers": {"type": "boolean", "description": "Whether to include the headers as keys in the JSON output. Default is true."}, "orientation": {"type": "string", "description": "The orientation of the JSON output. 'records' for list of records or 'columns' for columnar data. Default is 'records'.", "enum": ["records", "columns"]}}, "required": ["file_path"]}, "toolkit_name": "ExcelToolkit"}
{"name": "create_function_tool", "description": "Create a new function-based tool that OpenAI chat models can call, with support for schema parsing and synthesis.", "parameters": {"type": "object", "properties": {"tool_name": {"type": "string", "description": "The name of the new function tool."}, "tool_description": {"type": "string", "description": "A brief description of the function tool."}, "parameters": {"type": "object", "description": "The parameters that the function tool accepts.", "properties": {"type": {"type": "string", "description": "The type of the parameters object, must be 'object'.", "enum": ["object"]}, "properties": {"type": "object", "description": "The detailed information about the parameters.", "additionalProperties": {"type": "object", "properties": {"type": {"type": "string", "description": "The data type of the parameter, must be one of [integer, number, boolean, object, array].", "enum": ["integer", "number", "boolean", "object", "array"]}, "description": {"type": "string", "description": "A brief description of the parameter."}, "items": {"type": "object", "description": "Required if the parameter type is 'array'. Describes the type of items in the array.", "properties": {"type": {"type": "string", "description": "The data type of the items in the array.", "enum": ["integer", "number", "boolean", "object", "array"]}, "description": {"type": "string", "description": "A brief description of the items in the array."}}}}, "required": ["type", "description"]}}, "required": {"type": "array", "description": "A list of required parameters which must be inputted when invoking the tool.", "items": {"type": "string", "description": "The name of a required parameter."}}}, "required": ["type", "properties"]}}, "required": ["tool_name", "tool_description", "parameters"]}, "toolkit_name": "FunctionTool"}
{"name": "validate_function_schema", "description": "Validate the schema of a function-based tool to ensure compatibility with OpenAI chat models.", "parameters": {"type": "object", "properties": {"schema": {"type": "object", "description": "The schema of the function-based tool to be validated.", "properties": {"name": {"type": "string", "description": "The name of the function tool."}, "description": {"type": "string", "description": "A brief description of the function tool."}, "parameters": {"type": "object", "description": "The parameters the function tool accepts.", "properties": {"type": {"type": "string", "description": "The type of the parameters object, must be 'object'."}, "properties": {"type": "object", "description": "The properties of the parameters.", "additionalProperties": {"type": "object", "description": "Details of each parameter.", "properties": {"type": {"type": "string", "description": "The data type of the parameter, must be one of [integer, number, boolean, object, array]."}, "description": {"type": "string", "description": "A brief description of the parameter."}}, "required": ["type", "description"]}}, "required": {"type": "array", "description": "A list of required parameters.", "items": {"type": "string", "description": "The name of a required parameter."}}}, "required": ["type", "properties"]}}, "required": ["name", "description", "parameters"]}}, "required": ["schema"]}, "toolkit_name": "FunctionTool"}
{"name": "execute_function_tool", "description": "Execute a function-based tool with the provided parameters according to the specified schema.", "parameters": {"type": "object", "properties": {"function_name": {"type": "string", "description": "The name of the function to be executed."}, "parameters": {"type": "object", "description": "The parameters to be passed to the function, structured according to the function's schema.", "additionalProperties": {"type": ["integer", "number", "boolean", "object", "array", "string"], "description": "The value of the parameter, which can be of any valid JSON type."}}, "schema": {"type": "object", "description": "The schema defining the structure of the function's parameters.", "properties": {"type": {"type": "string", "description": "The type of the schema, typically 'object' for parameter schemas."}, "properties": {"type": "object", "description": "The properties of the schema, defining each parameter's name and type.", "additionalProperties": {"type": "object", "description": "The schema for an individual parameter.", "properties": {"type": {"type": "string", "description": "The data type of the parameter, one of ['integer', 'number', 'boolean', 'object', 'array', 'string']."}, "description": {"type": "string", "description": "A brief description of the parameter."}}, "required": ["type"]}}, "required": {"type": "array", "description": "A list of required parameter names.", "items": {"type": "string", "description": "The name of a required parameter."}}}, "required": ["type", "properties"]}}, "required": ["function_name", "parameters", "schema"]}, "toolkit_name": "FunctionTool"}
{"name": "generate_function_documentation", "description": "Generate documentation for a function-based tool, including its parameters, return type, and usage examples.", "parameters": {"type": "object", "properties": {"function_name": {"type": "string", "description": "The name of the function to document."}, "parameters": {"type": "array", "description": "The parameters of the function.", "items": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the parameter."}, "type": {"type": "string", "description": "The data type of the parameter."}, "description": {"type": "string", "description": "A brief description of the parameter."}, "required": {"type": "boolean", "description": "Whether the parameter is required."}}, "required": ["name", "type", "description"]}}, "return_type": {"type": "string", "description": "The return type of the function."}, "return_description": {"type": "string", "description": "A brief description of the return value."}, "usage_examples": {"type": "array", "description": "Example usages of the function.", "items": {"type": "string", "description": "An example usage of the function."}}}, "required": ["function_name", "parameters", "return_type"]}, "toolkit_name": "FunctionTool"}
{"name": "parse_function_response", "description": "Parse the response from a function call and validate it against the expected schema.", "parameters": {"type": "object", "properties": {"response": {"type": "object", "description": "The raw response object returned from the function call."}, "expected_schema": {"type": "object", "description": "The schema against which the response should be validated."}, "strict_validation": {"type": "boolean", "description": "Whether to enforce strict validation (all fields must match the schema exactly). Defaults to false."}}, "required": ["response", "expected_schema"]}, "toolkit_name": "FunctionTool"}
{"name": "write_to_file", "description": "Write or append text to a specified file. If the file does not exist, it will be created.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the file where the text will be written or appended."}, "content": {"type": "string", "description": "The text content to be written to the file."}, "mode": {"type": "string", "description": "The writing mode: 'write' to overwrite the file, 'append' to add to the end of the file.", "enum": ["write", "append"]}, "encoding": {"type": "string", "description": "The encoding type for the file, e.g., 'utf-8'.", "default": "utf-8"}}, "required": ["file_path", "content"]}, "toolkit_name": "FileWriteTool"}
{"name": "append_to_file", "description": "Append text to an existing file or create a new file if it does not exist.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the file where the text will be appended."}, "content": {"type": "string", "description": "The text content to append to the file."}, "create_if_not_exists": {"type": "boolean", "description": "Whether to create the file if it does not exist. Default is true."}}, "required": ["file_path", "content"]}, "toolkit_name": "FileWriteTool"}
{"name": "create_and_write_file", "description": "Create a new file and write content to it.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path where the new file will be created."}, "content": {"type": "string", "description": "The content to be written to the file."}, "overwrite": {"type": "boolean", "description": "Whether to overwrite the file if it already exists. Default is false."}}, "required": ["file_path", "content"]}, "toolkit_name": "FileWriteTool"}
{"name": "modify_file_content", "description": "Modify the content of an existing file by replacing specific text or adding new content at a specified position.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the file that needs to be modified."}, "old_text": {"type": "string", "description": "The text to be replaced in the file. Leave empty if only adding new text."}, "new_text": {"type": "string", "description": "The new text to replace the old text or to be added to the file."}, "position": {"type": "integer", "description": "The position in the file where the new text should be inserted. If not specified, the old_text will be replaced wherever it appears."}}, "required": ["file_path", "new_text"]}, "toolkit_name": "FileWriteTool"}
{"name": "replace_file_content", "description": "Replace specific content in a file with new content.", "parameters": {"type": "object", "properties": {"file_path": {"type": "string", "description": "The path to the file where content will be replaced."}, "old_content": {"type": "string", "description": "The content to be replaced in the file."}, "new_content": {"type": "string", "description": "The new content to replace the old content."}, "case_sensitive": {"type": "boolean", "description": "Whether the replacement should be case sensitive. Default is true.", "default": true}}, "required": ["file_path", "old_content", "new_content"]}, "toolkit_name": "FileWriteTool"}
{"name": "create_pull_request", "description": "Create a new pull request in a GitHub repository.", "parameters": {"type": "object", "properties": {"repository_owner": {"type": "string", "description": "The owner of the repository where the pull request will be created."}, "repository_name": {"type": "string", "description": "The name of the repository where the pull request will be created."}, "title": {"type": "string", "description": "The title of the pull request."}, "body": {"type": "string", "description": "The body or description of the pull request."}, "head": {"type": "string", "description": "The branch containing the changes you want to merge."}, "base": {"type": "string", "description": "The branch you want the changes pulled into."}, "draft": {"type": "boolean", "description": "Whether the pull request is a draft."}}, "required": ["repository_owner", "repository_name", "title", "head", "base"]}, "toolkit_name": "GitHubToolkit"}
{"name": "retrieve_issues", "description": "Retrieve issues from a GitHub repository based on specified criteria.", "parameters": {"type": "object", "properties": {"repository_owner": {"type": "string", "description": "The owner of the GitHub repository."}, "repository_name": {"type": "string", "description": "The name of the GitHub repository."}, "state": {"type": "string", "description": "The state of the issues to retrieve (open, closed, or all).", "enum": ["open", "closed", "all"]}, "labels": {"type": "array", "description": "The labels to filter issues by.", "items": {"type": "string", "description": "A label to filter issues by."}}, "sort": {"type": "string", "description": "The field to sort the issues by (created, updated, comments).", "enum": ["created", "updated", "comments"]}, "direction": {"type": "string", "description": "The direction to sort the issues (asc or desc).", "enum": ["asc", "desc"]}, "since": {"type": "string", "description": "Only issues updated at or after this time are returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ."}}, "required": ["repository_owner", "repository_name"]}, "toolkit_name": "GitHubToolkit"}
{"name": "merge_pull_request", "description": "Merge a pull request in a GitHub repository.", "parameters": {"type": "object", "properties": {"repository_owner": {"type": "string", "description": "The owner of the GitHub repository."}, "repository_name": {"type": "string", "description": "The name of the GitHub repository."}, "pull_request_number": {"type": "integer", "description": "The number of the pull request to be merged."}, "commit_title": {"type": "string", "description": "The title for the merge commit."}, "commit_message": {"type": "string", "description": "The message for the merge commit."}, "merge_method": {"type": "string", "description": "The merge method to use (merge, squash, or rebase).", "enum": ["merge", "squash", "rebase"]}}, "required": ["repository_owner", "repository_name", "pull_request_number"]}, "toolkit_name": "GitHubToolkit"}
{"name": "create_issue", "description": "Create a new issue in a GitHub repository.", "parameters": {"type": "object", "properties": {"repository_owner": {"type": "string", "description": "The owner of the GitHub repository."}, "repository_name": {"type": "string", "description": "The name of the GitHub repository."}, "title": {"type": "string", "description": "The title of the issue."}, "body": {"type": "string", "description": "The body content of the issue."}, "labels": {"type": "array", "description": "The labels to associate with the issue.", "items": {"type": "string", "description": "A label for the issue."}}, "assignees": {"type": "array", "description": "The GitHub usernames to assign to the issue.", "items": {"type": "string", "description": "A GitHub username to assign."}}}, "required": ["repository_owner", "repository_name", "title"]}, "toolkit_name": "GitHubToolkit"}
{"name": "add_collaborator", "description": "Add a collaborator to a GitHub repository.", "parameters": {"type": "object", "properties": {"repository_owner": {"type": "string", "description": "The owner of the repository."}, "repository_name": {"type": "string", "description": "The name of the repository."}, "username": {"type": "string", "description": "The GitHub username of the collaborator to be added."}, "permission": {"type": "string", "description": "The permission level to grant the collaborator. Must be one of ['pull', 'push', 'admin', 'maintain', 'triage'].", "enum": ["pull", "push", "admin", "maintain", "triage"]}}, "required": ["repository_owner", "repository_name", "username", "permission"]}, "toolkit_name": "GitHubToolkit"}
{"name": "get_elevation_data", "description": "Retrieve elevation data for specific locations using Google Maps Elevation API.", "parameters": {"type": "object", "properties": {"locations": {"type": "array", "description": "The locations for which elevation data is requested.", "items": {"type": "object", "properties": {"latitude": {"type": "number", "description": "The latitude of the location."}, "longitude": {"type": "number", "description": "The longitude of the location."}}, "required": ["latitude", "longitude"]}}, "unit_system": {"type": "string", "description": "The unit system in which to return elevation data. Must be either 'metric' (meters) or 'imperial' (feet).", "enum": ["metric", "imperial"]}}, "required": ["locations"]}, "toolkit_name": "GoogleMapsToolkit"}
{"name": "get_timezone_info", "description": "Retrieve the timezone information for a specific location based on latitude and longitude coordinates.", "parameters": {"type": "object", "properties": {"latitude": {"type": "number", "description": "The latitude coordinate of the location."}, "longitude": {"type": "number", "description": "The longitude coordinate of the location."}, "timestamp": {"type": "integer", "description": "The timestamp used to determine the timezone information. Defaults to the current time if not provided."}}, "required": ["latitude", "longitude"]}, "toolkit_name": "GoogleMapsToolkit"}
{"name": "validate_address", "description": "Validate and standardize an address using Google Maps services.", "parameters": {"type": "object", "properties": {"address": {"type": "string", "description": "The address to be validated and standardized."}, "region": {"type": "string", "description": "The region code, specified as a ccTLD (country code top-level domain) two-character value."}, "locale": {"type": "string", "description": "The language in which to return the results."}}, "required": ["address"]}, "toolkit_name": "GoogleMapsToolkit"}
{"name": "get_geolocation", "description": "Retrieve the geolocation (latitude and longitude) for a given address or place using Google Maps services.", "parameters": {"type": "object", "properties": {"address": {"type": "string", "description": "The address or place for which to retrieve geolocation data."}, "place_id": {"type": "string", "description": "The Google Maps Place ID for the location, if available."}, "components": {"type": "object", "description": "A component filter for more precise geolocation, e.g., { 'country': 'US' }.", "properties": {"country": {"type": "string", "description": "The country code to filter by, e.g., 'US' for United States."}, "locality": {"type": "string", "description": "The locality (city) to filter by."}, "postal_code": {"type": "string", "description": "The postal code to filter by."}}}}, "required": ["address"]}, "toolkit_name": "GoogleMapsToolkit"}
{"name": "get_place_details", "description": "Retrieve detailed information about a place using Google Maps services, including its address, contact information, and user ratings.", "parameters": {"type": "object", "properties": {"place_id": {"type": "string", "description": "The unique identifier for the place on Google Maps."}, "fields": {"type": "array", "description": "The specific fields to include in the response, such as 'formatted_address', 'name', 'rating', etc.", "items": {"type": "string", "description": "The field name to include in the response."}}, "language": {"type": "string", "description": "The language in which to return the results, specified as an IETF language tag."}, "region": {"type": "string", "description": "The region code, specified as a ccTLD (country code top-level domain)."}}, "required": ["place_id"]}, "toolkit_name": "GoogleMapsToolkit"}
{"name": "get_author_publications", "description": "Retrieve a list of publications by a specific author from Google Scholar.", "parameters": {"type": "object", "properties": {"author_name": {"type": "string", "description": "The name of the author whose publications are to be retrieved."}, "max_results": {"type": "integer", "description": "The maximum number of publications to retrieve.", "minimum": 1, "maximum": 100}, "include_citations": {"type": "boolean", "description": "Whether to include citation counts for each publication."}, "publication_year": {"type": "integer", "description": "Filter publications by a specific year.", "minimum": 1900, "maximum": 2100}}, "required": ["author_name"]}, "toolkit_name": "GoogleScholarToolkit"}
{"name": "search_author", "description": "Search for an author on Google Scholar and retrieve their profile information.", "parameters": {"type": "object", "properties": {"author_name": {"type": "string", "description": "The name of the author to search for."}, "affiliation": {"type": "string", "description": "The affiliation of the author (e.g., university or organization)."}, "include_citations": {"type": "boolean", "description": "Whether to include citation metrics in the results."}, "include_coauthors": {"type": "boolean", "description": "Whether to include co-authors in the results."}, "max_results": {"type": "integer", "description": "The maximum number of results to return."}}, "required": ["author_name"]}, "toolkit_name": "GoogleScholarToolkit"}
{"name": "get_publication_details", "description": "Retrieve detailed information about a specific publication from Google Scholar using its unique identifier.", "parameters": {"type": "object", "properties": {"publication_id": {"type": "string", "description": "The unique identifier of the publication on Google Scholar."}, "include_citations": {"type": "boolean", "description": "Whether to include citation details in the response.", "default": false}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract of the publication in the response.", "default": false}, "include_related_articles": {"type": "boolean", "description": "Whether to include a list of related articles in the response.", "default": false}}, "required": ["publication_id"]}, "toolkit_name": "GoogleScholarToolkit"}
{"name": "get_citation_graph", "description": "Retrieve the citation graph for a specific publication, including papers that cite it and papers it references.", "parameters": {"type": "object", "properties": {"publication_id": {"type": "string", "description": "The unique identifier of the publication on Google Scholar."}, "depth": {"type": "integer", "description": "The depth of the citation graph to retrieve (e.g., 1 for direct citations/references, 2 for citations of citations, etc.).", "minimum": 1, "maximum": 5}, "include_abstracts": {"type": "boolean", "description": "Whether to include abstracts of the citing/referenced papers in the results.", "default": false}}, "required": ["publication_id"]}, "toolkit_name": "GoogleScholarToolkit"}
{"name": "get_author_stats", "description": "Retrieve statistics about an author from Google Scholar, including citation counts, h-index, and i10-index.", "parameters": {"type": "object", "properties": {"author_id": {"type": "string", "description": "The unique identifier of the author on Google Scholar."}, "include_citation_graph": {"type": "boolean", "description": "Whether to include the citation graph data in the response."}, "include_publications": {"type": "boolean", "description": "Whether to include a list of the author's publications in the response."}}, "required": ["author_id"]}, "toolkit_name": "GoogleScholarToolkit"}
{"name": "request_human_feedback", "description": "Request feedback from a human user on a specific task or output.", "parameters": {"type": "object", "properties": {"task_description": {"type": "string", "description": "A brief description of the task or output for which feedback is being requested."}, "output_to_review": {"type": "string", "description": "The output or result that needs human review."}, "feedback_questions": {"type": "array", "description": "A list of specific questions to guide the human feedback.", "items": {"type": "string", "description": "A question to prompt the human reviewer for feedback."}}, "urgency": {"type": "integer", "description": "The urgency level of the feedback request, ranging from 1 (low) to 5 (high)."}, "allowed_time": {"type": "number", "description": "The maximum time (in minutes) allocated for the human to provide feedback."}}, "required": ["task_description", "output_to_review"]}, "toolkit_name": "HumanToolkit"}
{"name": "schedule_human_review", "description": "Schedule a human review for a specific task or output generated by the AI system.", "parameters": {"type": "object", "properties": {"task_id": {"type": "string", "description": "The unique identifier for the task to be reviewed."}, "reviewers": {"type": "array", "description": "List of reviewers assigned to the task.", "items": {"type": "string", "description": "The identifier or email of the reviewer."}}, "deadline": {"type": "string", "description": "The deadline for completing the review in ISO 8601 format."}, "priority": {"type": "string", "description": "The priority level of the review task (e.g., low, medium, high)."}, "notes": {"type": "string", "description": "Additional notes or instructions for the reviewers."}}, "required": ["task_id", "reviewers", "deadline"]}, "toolkit_name": "HumanToolkit"}
{"name": "collect_human_preferences", "description": "Collect preferences or choices from a human user for AI system customization or decision-making.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the user providing the preferences."}, "preferences": {"type": "array", "description": "A list of preference options presented to the user.", "items": {"type": "object", "properties": {"option_id": {"type": "string", "description": "The unique identifier for the preference option."}, "description": {"type": "string", "description": "A brief description of the preference option."}}, "required": ["option_id", "description"]}}, "multiple_selection": {"type": "boolean", "description": "Whether the user can select multiple preferences or just one."}, "timeout": {"type": "integer", "description": "The maximum time in seconds to wait for the user's response before timing out."}}, "required": ["user_id", "preferences"]}, "toolkit_name": "HumanToolkit"}
{"name": "submit_human_annotation", "description": "Submit a task for human annotation, such as labeling, classification, or other forms of data annotation.", "parameters": {"type": "object", "properties": {"task_description": {"type": "string", "description": "A detailed description of the annotation task."}, "data": {"type": "array", "description": "The data items that require human annotation.", "items": {"type": "object", "description": "A single data item to be annotated."}}, "annotation_guidelines": {"type": "string", "description": "Guidelines or instructions for the human annotators."}, "deadline": {"type": "string", "description": "The deadline for completing the annotation task."}, "priority": {"type": "string", "description": "The priority level of the annotation task (e.g., low, medium, high)."}}, "required": ["task_description", "data", "annotation_guidelines"]}, "toolkit_name": "HumanToolkit"}
{"name": "request_human_validation", "description": "Request human validation for a specific task or decision made by the AI system.", "parameters": {"type": "object", "properties": {"task_id": {"type": "string", "description": "The unique identifier for the task requiring human validation."}, "task_description": {"type": "string", "description": "A detailed description of the task or decision to be validated."}, "validation_criteria": {"type": "array", "description": "The criteria or questions the human validator should consider.", "items": {"type": "string", "description": "A specific criterion or question for validation."}}, "priority": {"type": "string", "description": "The priority level of the validation request (e.g., low, medium, high).", "enum": ["low", "medium", "high"]}, "deadline": {"type": "string", "description": "The deadline by which the validation should be completed (ISO 8601 format)."}}, "required": ["task_id", "task_description", "validation_criteria"]}, "toolkit_name": "HumanToolkit"}
{"name": "analyze_image_objects", "description": "Analyze objects within an image and provide detailed information about each detected object.", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path or URL of the image to be analyzed."}, "confidence_threshold": {"type": "number", "description": "The minimum confidence score (between 0 and 1) required for an object to be included in the results.", "minimum": 0, "maximum": 1}, "max_objects": {"type": "integer", "description": "The maximum number of objects to detect and analyze in the image.", "minimum": 1}, "include_attributes": {"type": "array", "description": "A list of attributes to include for each detected object (e.g., 'color', 'size', 'position').", "items": {"type": "string", "description": "The attribute to include for each detected object."}}}, "required": ["image_path"]}, "toolkit_name": "ImageAnalysisToolkit"}
{"name": "extract_image_text", "description": "Extract and analyze text from an image using optical character recognition (OCR).", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path or URL of the image from which text needs to be extracted."}, "language": {"type": "string", "description": "The language of the text in the image for improved OCR accuracy.", "default": "eng"}, "output_format": {"type": "string", "description": "The format in which the extracted text should be returned (e.g., 'plain_text', 'json').", "default": "plain_text"}, "include_confidence": {"type": "boolean", "description": "Whether to include confidence scores for each extracted text element.", "default": false}}, "required": ["image_path"]}, "toolkit_name": "ImageAnalysisToolkit"}
{"name": "detect_image_colors", "description": "Analyze and detect dominant colors in an image.", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path or URL of the image to be analyzed."}, "color_count": {"type": "integer", "description": "The number of dominant colors to detect in the image.", "minimum": 1, "maximum": 10}, "include_hex": {"type": "boolean", "description": "Whether to include hexadecimal color codes in the result.", "default": true}, "include_rgb": {"type": "boolean", "description": "Whether to include RGB color values in the result.", "default": true}, "include_percentage": {"type": "boolean", "description": "Whether to include the percentage of each color in the image.", "default": true}}, "required": ["image_path"]}, "toolkit_name": "ImageAnalysisToolkit"}
{"name": "identify_image_scenes", "description": "Identify and describe scenes or settings within an image.", "parameters": {"type": "object", "properties": {"image_path": {"type": "string", "description": "The local path or URL of the image to be analyzed."}, "detailed": {"type": "boolean", "description": "Whether to provide a detailed description of the scenes. Default is false."}, "max_results": {"type": "integer", "description": "The maximum number of scene descriptions to return. Default is 3."}}, "required": ["image_path"]}, "toolkit_name": "ImageAnalysisToolkit"}
{"name": "compare_image_similarity", "description": "Compare the similarity between two images based on visual features and content.", "parameters": {"type": "object", "properties": {"image1_path": {"type": "string", "description": "The local path or URL of the first image to be compared."}, "image2_path": {"type": "string", "description": "The local path or URL of the second image to be compared."}, "similarity_threshold": {"type": "number", "description": "The threshold value (between 0 and 1) to determine if the images are considered similar. Default is 0.8.", "default": 0.8}, "return_features": {"type": "boolean", "description": "Whether to return the extracted visual features used for comparison. Default is false.", "default": false}}, "required": ["image1_path", "image2_path"]}, "toolkit_name": "ImageAnalysisToolkit"}
{"name": "retrieve_user_profile", "description": "Retrieve the profile information of a LinkedIn user.", "parameters": {"type": "object", "properties": {"user_id": {"type": "string", "description": "The unique identifier of the LinkedIn user."}, "fields": {"type": "array", "description": "The specific fields of the profile to retrieve.", "items": {"type": "string", "description": "The field name, e.g., 'name', 'headline', 'experience', etc."}}}, "required": ["user_id"]}, "toolkit_name": "LinkedInToolkit"}
{"name": "create_post", "description": "Create a new post on LinkedIn.", "parameters": {"type": "object", "properties": {"content": {"type": "string", "description": "The content of the post to be created."}, "visibility": {"type": "string", "description": "The visibility of the post, e.g., 'PUBLIC', 'CONNECTIONS', etc."}, "media_url": {"type": "string", "description": "The URL of the media to be attached to the post (optional)."}, "media_type": {"type": "string", "description": "The type of media being attached, e.g., 'IMAGE', 'VIDEO' (required if media_url is provided)."}}, "required": ["content", "visibility"]}, "toolkit_name": "LinkedInToolkit"}
{"name": "delete_post", "description": "Delete a post on LinkedIn.", "parameters": {"type": "object", "properties": {"post_id": {"type": "string", "description": "The unique identifier of the post to be deleted."}}, "required": ["post_id"]}, "toolkit_name": "LinkedInToolkit"}
{"name": "search_connections", "description": "Search for LinkedIn connections based on specified criteria such as name, company, or industry.", "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the connection to search for."}, "company": {"type": "string", "description": "The company name to filter connections by."}, "industry": {"type": "string", "description": "The industry to filter connections by."}, "max_results": {"type": "integer", "description": "The maximum number of results to return.", "minimum": 1, "maximum": 100}}, "required": []}, "toolkit_name": "LinkedInToolkit"}
{"name": "update_profile", "description": "Update the user's LinkedIn profile information.", "parameters": {"type": "object", "properties": {"headline": {"type": "string", "description": "The headline to be displayed on the user's profile."}, "summary": {"type": "string", "description": "The summary section of the user's profile."}, "experience": {"type": "array", "description": "List of professional experiences to be added or updated.", "items": {"type": "object", "properties": {"title": {"type": "string", "description": "The job title for the experience."}, "company": {"type": "string", "description": "The company name for the experience."}, "duration": {"type": "string", "description": "The duration of the experience (e.g., '2015-2020')."}, "description": {"type": "string", "description": "A brief description of the experience."}}, "required": ["title", "company"]}}, "education": {"type": "array", "description": "List of educational qualifications to be added or updated.", "items": {"type": "object", "properties": {"school": {"type": "string", "description": "The name of the educational institution."}, "degree": {"type": "string", "description": "The degree obtained."}, "field_of_study": {"type": "string", "description": "The field of study."}, "duration": {"type": "string", "description": "The duration of the education (e.g., '2010-2014')."}}, "required": ["school", "degree"]}}, "skills": {"type": "array", "description": "List of skills to be added or updated on the profile.", "items": {"type": "string", "description": "A skill to be listed on the profile."}}}, "required": []}, "toolkit_name": "LinkedInToolkit"}
{"name": "divide_numbers", "description": "Divide two numbers and return the result.", "parameters": {"type": "object", "properties": {"dividend": {"type": "number", "description": "The number to be divided."}, "divisor": {"type": "number", "description": "The number to divide by."}}, "required": ["dividend", "divisor"]}, "toolkit_name": "MathToolkit"}
{"name": "calculate_power", "description": "Calculate the power of a base number raised to an exponent.", "parameters": {"type": "object", "properties": {"base": {"type": "number", "description": "The base number."}, "exponent": {"type": "number", "description": "The exponent to which the base is raised."}}, "required": ["base", "exponent"]}, "toolkit_name": "MathToolkit"}
{"name": "calculate_sum", "description": "Calculate the sum of a list of numbers.", "parameters": {"type": "object", "properties": {"numbers": {"type": "array", "description": "The list of numbers to be summed.", "items": {"type": "number", "description": "A number to be included in the sum."}}}, "required": ["numbers"]}, "toolkit_name": "MathToolkit"}
{"name": "calculate_product", "description": "Calculate the product of a list of numbers.", "parameters": {"type": "object", "properties": {"numbers": {"type": "array", "description": "The list of numbers to multiply together.", "items": {"type": "number", "description": "A number to be included in the product calculation."}}}, "required": ["numbers"]}, "toolkit_name": "MathToolkit"}
{"name": "calculate_difference", "description": "Calculate the difference between two numbers.", "parameters": {"type": "object", "properties": {"number1": {"type": "number", "description": "The first number."}, "number2": {"type": "number", "description": "The second number."}}, "required": ["number1", "number2"]}, "toolkit_name": "MathToolkit"}
{"name": "execute_mcp_command", "description": "Execute a command using the Model Context Protocol (MCP) to interact with external tools.", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The MCP command to be executed."}, "parameters": {"type": "object", "description": "The parameters required for the MCP command.", "additionalProperties": {"type": "string", "description": "The value of the parameter."}}, "timeout": {"type": "integer", "description": "The timeout duration in milliseconds for the command execution."}, "async": {"type": "boolean", "description": "Whether the command should be executed asynchronously."}}, "required": ["command"]}, "toolkit_name": "MCPToolkit"}
{"name": "fetch_mcp_data", "description": "Fetch data from an external tool using the Model Context Protocol (MCP).", "parameters": {"type": "object", "properties": {"tool_id": {"type": "string", "description": "The unique identifier of the external tool to interact with."}, "query": {"type": "object", "description": "The query parameters to fetch the data.", "properties": {"command": {"type": "string", "description": "The command to execute on the external tool."}, "args": {"type": "object", "description": "Additional arguments for the command.", "properties": {}}}}, "timeout": {"type": "integer", "description": "The maximum time in milliseconds to wait for a response.", "minimum": 0}}, "required": ["tool_id", "query"]}, "toolkit_name": "MCPToolkit"}
{"name": "query_mcp_status", "description": "Query the status of an external tool connected via the Model Context Protocol (MCP).", "parameters": {"type": "object", "properties": {"tool_id": {"type": "string", "description": "The unique identifier of the external tool."}, "detailed": {"type": "boolean", "description": "Whether to return detailed status information. Default is false."}, "timeout": {"type": "integer", "description": "The maximum time in milliseconds to wait for a response. Default is 5000."}}, "required": ["tool_id"]}, "toolkit_name": "MCPToolkit"}
{"name": "subscribe_mcp_event", "description": "Subscribe to events from an external tool using the Model Context Protocol (MCP).", "parameters": {"type": "object", "properties": {"event_type": {"type": "string", "description": "The type of event to subscribe to."}, "callback_url": {"type": "string", "description": "The URL to which event notifications will be sent."}, "filter_criteria": {"type": "object", "description": "Optional criteria to filter the events.", "properties": {"key": {"type": "string", "description": "The attribute to filter on."}, "value": {"type": "string", "description": "The value to match for the specified attribute."}}}, "timeout": {"type": "integer", "description": "The duration in seconds before the subscription expires."}}, "required": ["event_type", "callback_url"]}, "toolkit_name": "MCPToolkit"}
{"name": "update_mcp_configuration", "description": "Update the configuration settings for an external tool connected via the Model Context Protocol (MCP).", "parameters": {"type": "object", "properties": {"tool_id": {"type": "string", "description": "The unique identifier of the external tool."}, "configurations": {"type": "object", "description": "The new configuration settings to apply.", "properties": {"timeout": {"type": "integer", "description": "The timeout duration in milliseconds for operations."}, "retry_attempts": {"type": "integer", "description": "The number of retry attempts for failed operations."}, "logging_level": {"type": "string", "description": "The logging level (e.g., 'debug', 'info', 'warn', 'error')."}}}}, "required": ["tool_id", "configurations"]}, "toolkit_name": "MCPToolkit"}
{"name": "save_memory", "description": "Save the current state of the ChatAgent's memory to a specified location.", "parameters": {"type": "object", "properties": {"memory_data": {"type": "object", "description": "The memory data to be saved, which can include various types of information stored by the ChatAgent."}, "file_path": {"type": "string", "description": "The local file path where the memory data will be saved."}, "overwrite": {"type": "boolean", "description": "Whether to overwrite the file if it already exists. Default is false."}}, "required": ["memory_data", "file_path"]}, "toolkit_name": "MemoryToolkit"}
{"name": "load_memory", "description": "Load the ChatAgent's memory from storage.", "parameters": {"type": "object", "properties": {"memory_id": {"type": "string", "description": "The unique identifier for the memory to be loaded."}}, "required": ["memory_id"]}, "toolkit_name": "MemoryToolkit"}
{"name": "clear_memory", "description": "Clear the ChatAgent's memory.", "parameters": {"type": "object", "properties": {"memory_id": {"type": "string", "description": "The identifier of the memory to be cleared."}}, "required": ["memory_id"]}, "toolkit_name": "MemoryToolkit"}
{"name": "update_memory", "description": "Update a specific memory entry in the ChatAgent's memory.", "parameters": {"type": "object", "properties": {"memory_key": {"type": "string", "description": "The key of the memory entry to be updated."}, "new_value": {"type": "string", "description": "The new value to update the memory entry with."}}, "required": ["memory_key", "new_value"]}, "toolkit_name": "MemoryToolkit"}
{"name": "search_memory", "description": "Search for specific content within the ChatAgent's memory.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term or phrase to look for in the memory."}, "case_sensitive": {"type": "boolean", "description": "Whether the search should be case sensitive. Default is false."}, "limit": {"type": "integer", "description": "The maximum number of results to return. Default is 10."}}, "required": ["query"]}, "toolkit_name": "MemoryToolkit"}
{"name": "calculate_mesh_volume", "description": "Calculate the volume of a 3D mesh.", "parameters": {"type": "object", "properties": {"mesh_data": {"type": "object", "description": "The 3D mesh data in a supported format (e.g., OBJ, STL)."}, "unit": {"type": "string", "description": "The unit of measurement for the volume (e.g., 'mm', 'cm', 'm').", "default": "mm"}, "precision": {"type": "integer", "description": "The number of decimal places to round the volume result.", "default": 2}}, "required": ["mesh_data"]}, "toolkit_name": "MeshyToolkit"}
{"name": "compute_mesh_surface_area", "description": "Calculate the surface area of a 3D mesh.", "parameters": {"type": "object", "properties": {"mesh_data": {"type": "object", "description": "The 3D mesh data in a supported format (e.g., OBJ, STL)."}, "unit": {"type": "string", "description": "The unit of measurement for the surface area (e.g., 'mm', 'cm', 'm').", "default": "m"}}, "required": ["mesh_data"]}, "toolkit_name": "MeshyToolkit"}
{"name": "convert_mesh_format", "description": "Convert a 3D mesh file from one format to another.", "parameters": {"type": "object", "properties": {"input_file": {"type": "string", "description": "The path to the input mesh file."}, "output_format": {"type": "string", "description": "The desired output format for the mesh file (e.g., 'obj', 'stl', 'ply')."}, "output_file": {"type": "string", "description": "The path where the converted mesh file will be saved."}, "preserve_normals": {"type": "boolean", "description": "Whether to preserve the normals during conversion. Default is true.", "default": true}, "preserve_textures": {"type": "boolean", "description": "Whether to preserve the textures during conversion. Default is true.", "default": true}}, "required": ["input_file", "output_format", "output_file"]}, "toolkit_name": "MeshyToolkit"}
{"name": "extract_mesh_boundary", "description": "Extract the boundary edges or vertices of a 3D mesh.", "parameters": {"type": "object", "properties": {"mesh_data": {"type": "object", "description": "The 3D mesh data from which the boundary will be extracted."}, "extract_type": {"type": "string", "description": "The type of boundary to extract, either 'edges' or 'vertices'.", "enum": ["edges", "vertices"]}, "include_indices": {"type": "boolean", "description": "Whether to include the indices of the boundary elements in the output.", "default": false}}, "required": ["mesh_data", "extract_type"]}, "toolkit_name": "MeshyToolkit"}
{"name": "smooth_mesh_surface", "description": "Apply smoothing to the surface of a 3D mesh to reduce noise and improve visual quality.", "parameters": {"type": "object", "properties": {"mesh_data": {"type": "object", "description": "The 3D mesh data to be smoothed."}, "iterations": {"type": "integer", "description": "The number of smoothing iterations to apply.", "minimum": 1, "maximum": 10}, "lambda_value": {"type": "number", "description": "The lambda parameter controlling the smoothing intensity.", "minimum": 0.1, "maximum": 1.0}, "preserve_boundary": {"type": "boolean", "description": "Whether to preserve the mesh boundary during smoothing."}}, "required": ["mesh_data", "iterations"]}, "toolkit_name": "MeshyToolkit"}
{"name": "extract_text_with_ocr", "description": "Extract text from a document using OCR (Optical Character Recognition) technology.", "parameters": {"type": "object", "properties": {"document_path": {"type": "string", "description": "The local path or URL of the document to process."}, "language": {"type": "string", "description": "The language of the text in the document for better OCR accuracy."}, "output_format": {"type": "string", "description": "The format of the output text, e.g., 'plain_text' or 'json'.", "enum": ["plain_text", "json"]}, "enhance_quality": {"type": "boolean", "description": "Whether to enhance the quality of the document before processing."}}, "required": ["document_path"]}, "toolkit_name": "MinerUToolkit"}
{"name": "detect_tables", "description": "Detect and extract tables from a document using the MinerU API.", "parameters": {"type": "object", "properties": {"document_path": {"type": "string", "description": "The local path or URL of the document to process."}, "output_format": {"type": "string", "description": "The format of the output table data. Options include 'csv', 'json', or 'html'.", "default": "json"}, "include_headers": {"type": "boolean", "description": "Whether to include headers in the detected tables.", "default": true}, "merge_cells": {"type": "boolean", "description": "Whether to merge cells with similar content in the detected tables.", "default": false}}, "required": ["document_path"]}, "toolkit_name": "MinerUToolkit"}
{"name": "recognize_formulas", "description": "Recognize and extract mathematical formulas from a document using OCR and formula recognition.", "parameters": {"type": "object", "properties": {"document_path": {"type": "string", "description": "The local path or URL of the document containing the formulas."}, "output_format": {"type": "string", "description": "The format of the output, e.g., LaTeX or MathML.", "enum": ["LaTeX", "MathML"], "default": "LaTeX"}, "include_context": {"type": "boolean", "description": "Whether to include the surrounding text context of the formulas.", "default": false}}, "required": ["document_path"]}, "toolkit_name": "MinerUToolkit"}
{"name": "extract_structured_content", "description": "Extract structured content from a document, including text, tables, and formulas, using the MinerU API.", "parameters": {"type": "object", "properties": {"document_path": {"type": "string", "description": "The local path or URL of the document to be processed."}, "include_text": {"type": "boolean", "description": "Whether to include extracted text in the output.", "default": true}, "include_tables": {"type": "boolean", "description": "Whether to include detected tables in the output.", "default": true}, "include_formulas": {"type": "boolean", "description": "Whether to include recognized formulas in the output.", "default": true}, "output_format": {"type": "string", "description": "The format of the output, either 'json' or 'xml'.", "default": "json"}}, "required": ["document_path"]}, "toolkit_name": "MinerUToolkit"}
{"name": "convert_to_markdown", "description": "Convert extracted document content into Markdown format for easy readability and further processing.", "parameters": {"type": "object", "properties": {"content": {"type": "object", "description": "The extracted content from the document, which can include text, tables, and formulas."}, "include_tables": {"type": "boolean", "description": "Whether to include detected tables in the Markdown output. Default is true."}, "include_formulas": {"type": "boolean", "description": "Whether to include recognized formulas in the Markdown output. Default is true."}, "format_options": {"type": "object", "description": "Additional formatting options for the Markdown output.", "properties": {"header_level": {"type": "integer", "description": "The base header level for the Markdown output. Default is 1."}, "escape_special_chars": {"type": "boolean", "description": "Whether to escape special characters in the Markdown output. Default is true."}}}}, "required": ["content"]}, "toolkit_name": "MinerUToolkit"}
{"name": "find_shortest_path", "description": "Find the shortest path between two nodes in a graph using Dijkstra's algorithm.", "parameters": {"type": "object", "properties": {"graph": {"type": "object", "description": "The graph object represented in NetworkX format."}, "source": {"type": "string", "description": "The starting node of the path."}, "target": {"type": "string", "description": "The ending node of the path."}, "weight": {"type": "string", "description": "The edge attribute to be used as the weight for the path calculation.", "default": "weight"}}, "required": ["graph", "source", "target"]}, "toolkit_name": "NetworkXToolkit"}
{"name": "compute_pagerank", "description": "Compute the PageRank of nodes in a graph to determine their importance.", "parameters": {"type": "object", "properties": {"graph": {"type": "object", "description": "The graph object on which PageRank will be computed."}, "alpha": {"type": "number", "description": "Damping parameter for PageRank, default is 0.85.", "default": 0.85}, "max_iter": {"type": "integer", "description": "Maximum number of iterations, default is 100.", "default": 100}, "tol": {"type": "number", "description": "Error tolerance for convergence, default is 1.0e-6.", "default": 1e-06}, "weight": {"type": "string", "description": "Edge attribute to use as weight, default is None.", "default": null}}, "required": ["graph"]}, "toolkit_name": "NetworkXToolkit"}
{"name": "find_connected_components", "description": "Find all connected components in a graph.", "parameters": {"type": "object", "properties": {"graph": {"type": "object", "description": "The graph object to analyze, represented as a NetworkX graph."}, "directed": {"type": "boolean", "description": "Whether the graph is directed. Default is False."}}, "required": ["graph"]}, "toolkit_name": "NetworkXToolkit"}
{"name": "compute_betweenness_centrality", "description": "Compute the betweenness centrality for nodes in a graph. Betweenness centrality is a measure of centrality in a graph based on shortest paths.", "parameters": {"type": "object", "properties": {"graph": {"type": "object", "description": "The graph object on which to compute betweenness centrality. The graph should be a NetworkX graph object."}, "normalized": {"type": "boolean", "description": "If True, the betweenness values are normalized by 2/((n-1)(n-2)) for graphs, and 1/((n-1)(n-2)) for directed graphs where n is the number of nodes in the graph."}, "weight": {"type": "string", "description": "If None, all edge weights are considered equal. Otherwise, holds the name of the edge attribute used as weight."}, "endpoints": {"type": "boolean", "description": "If True, includes the endpoints in the shortest path counts."}, "k": {"type": "integer", "description": "The number of nodes to use for sampling in the approximation of betweenness centrality. If not provided, the exact betweenness centrality is computed."}, "seed": {"type": "integer", "description": "The seed for the random number generator used in the approximation algorithm."}}, "required": ["graph"]}, "toolkit_name": "NetworkXToolkit"}
{"name": "compute_clustering_coefficient", "description": "Compute the clustering coefficient for nodes in a graph. The clustering coefficient is a measure of the degree to which nodes in a graph tend to cluster together.", "parameters": {"type": "object", "properties": {"graph": {"type": "object", "description": "The graph object from NetworkX on which the clustering coefficient will be computed."}, "nodes": {"type": "array", "description": "The nodes for which the clustering coefficient will be computed. If not provided, the coefficient will be computed for all nodes.", "items": {"type": "string", "description": "The node identifier."}}, "weight": {"type": "string", "description": "The edge attribute that holds the numerical value used as weight. If None, all edges are considered equal."}}, "required": ["graph"]}, "toolkit_name": "NetworkXToolkit"}
{"name": "retrieve_page_content", "description": "Retrieve the content of a specific Notion page using its page ID.", "parameters": {"type": "object", "properties": {"page_id": {"type": "string", "description": "The unique identifier of the Notion page."}, "include_children": {"type": "boolean", "description": "Whether to include child blocks in the retrieved content. Default is false."}, "filter_properties": {"type": "array", "description": "List of property names to include in the response. If not specified, all properties are included.", "items": {"type": "string", "description": "The name of a property to include."}}}, "required": ["page_id"]}, "toolkit_name": "NotionToolkit"}
{"name": "search_notion_workspace", "description": "Search for pages, databases, or other items in a Notion workspace using the Notion API.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to match against page titles, database names, or content."}, "filter": {"type": "object", "description": "Additional filters to narrow down the search results.", "properties": {"object_type": {"type": "string", "description": "The type of object to search for (e.g., 'page', 'database')."}, "last_edited_time": {"type": "string", "description": "Filter results by the last edited time (e.g., '2023-01-01')."}}}, "sort": {"type": "object", "description": "Specifies how to sort the search results.", "properties": {"direction": {"type": "string", "description": "The sort direction (e.g., 'ascending', 'descending')."}, "timestamp": {"type": "string", "description": "The timestamp to sort by (e.g., 'last_edited_time')."}}}, "page_size": {"type": "integer", "description": "The maximum number of items to return in the search results."}}, "required": ["query"]}, "toolkit_name": "NotionToolkit"}
{"name": "get_page_properties", "description": "Retrieve the properties of a specific Notion page.", "parameters": {"type": "object", "properties": {"page_id": {"type": "string", "description": "The unique identifier of the Notion page."}, "property_names": {"type": "array", "description": "The names of the properties to retrieve from the page.", "items": {"type": "string", "description": "The name of a specific property on the Notion page."}}}, "required": ["page_id"]}, "toolkit_name": "NotionToolkit"}
{"name": "retrieve_database_entries", "description": "Retrieve entries from a specified Notion database using the Notion API.", "parameters": {"type": "object", "properties": {"database_id": {"type": "string", "description": "The ID of the Notion database to retrieve entries from."}, "filter": {"type": "object", "description": "The filter conditions to apply when retrieving entries.", "properties": {"property": {"type": "string", "description": "The property to filter by."}, "condition": {"type": "string", "description": "The condition to apply (e.g., equals, contains)."}, "value": {"type": "string", "description": "The value to compare against."}}}, "sorts": {"type": "array", "description": "The sorting conditions to apply when retrieving entries.", "items": {"type": "object", "properties": {"property": {"type": "string", "description": "The property to sort by."}, "direction": {"type": "string", "description": "The direction to sort in (e.g., ascending, descending)."}}}}, "page_size": {"type": "integer", "description": "The maximum number of entries to retrieve."}}, "required": ["database_id"]}, "toolkit_name": "NotionToolkit"}
{"name": "create_notion_page", "description": "Create a new page in a Notion workspace or database.", "parameters": {"type": "object", "properties": {"parent_id": {"type": "string", "description": "The ID of the parent page or database where the new page will be created."}, "title": {"type": "string", "description": "The title of the new page."}, "properties": {"type": "object", "description": "Additional properties of the page, such as custom fields in a database."}, "content": {"type": "array", "description": "The content blocks of the page.", "items": {"type": "object", "description": "A content block, which can be text, headings, lists, etc."}}}, "required": ["parent_id", "title"]}, "toolkit_name": "NotionToolkit"}
{"name": "validate_openapi_spec", "description": "Validate an OpenAPI specification file to ensure it conforms to the OpenAPI standards.", "parameters": {"type": "object", "properties": {"spec_file_path": {"type": "string", "description": "The local path or URL to the OpenAPI specification file."}, "strict_mode": {"type": "boolean", "description": "Whether to enable strict mode validation, which checks for additional best practices."}, "output_format": {"type": "string", "description": "The format of the validation output. Options are 'json' or 'text'.", "enum": ["json", "text"]}}, "required": ["spec_file_path"]}, "toolkit_name": "OpenAPIToolkit"}
{"name": "generate_openapi_client", "description": "Generate a client library for interacting with an API based on its OpenAPI specification.", "parameters": {"type": "object", "properties": {"spec_url": {"type": "string", "description": "The URL or local path to the OpenAPI specification file."}, "language": {"type": "string", "description": "The programming language for which the client library should be generated."}, "output_dir": {"type": "string", "description": "The directory where the generated client library should be saved."}, "options": {"type": "object", "description": "Additional options for the client generation process.", "properties": {"async": {"type": "boolean", "description": "Whether to generate asynchronous client code."}, "package_name": {"type": "string", "description": "The name of the package for the generated client."}, "additional_properties": {"type": "object", "description": "Any additional properties to pass to the generator."}}}}, "required": ["spec_url", "language", "output_dir"]}, "toolkit_name": "OpenAPIToolkit"}
{"name": "convert_openapi_to_postman", "description": "Convert an OpenAPI specification to a Postman collection.", "parameters": {"type": "object", "properties": {"openapi_spec": {"type": "string", "description": "The OpenAPI specification in JSON or YAML format."}, "output_format": {"type": "string", "description": "The desired output format for the Postman collection. Options are 'json' or 'yaml'.", "enum": ["json", "yaml"]}, "include_examples": {"type": "boolean", "description": "Whether to include example requests and responses in the Postman collection."}, "environment_variables": {"type": "array", "description": "A list of environment variables to include in the Postman collection.", "items": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the environment variable."}, "value": {"type": "string", "description": "The value of the environment variable."}}, "required": ["name", "value"]}}}, "required": ["openapi_spec"]}, "toolkit_name": "OpenAPIToolkit"}
{"name": "extract_openapi_endpoints", "description": "Extract all endpoints from an OpenAPI specification.", "parameters": {"type": "object", "properties": {"spec_path": {"type": "string", "description": "The local path or URL to the OpenAPI specification file."}, "include_deprecated": {"type": "boolean", "description": "Whether to include deprecated endpoints in the result. Default is false."}, "filter_methods": {"type": "array", "description": "Filter endpoints by HTTP methods. If empty, all methods are included.", "items": {"type": "string", "description": "The HTTP method to filter by (e.g., 'get', 'post', 'put', 'delete')."}}}, "required": ["spec_path"]}, "toolkit_name": "OpenAPIToolkit"}
{"name": "generate_openapi_documentation", "description": "Generate human-readable documentation from an OpenAPI specification.", "parameters": {"type": "object", "properties": {"openapi_spec": {"type": "object", "description": "The OpenAPI specification object to generate documentation from."}, "output_format": {"type": "string", "description": "The format of the generated documentation. Options include 'html', 'markdown', or 'pdf'.", "enum": ["html", "markdown", "pdf"]}, "include_examples": {"type": "boolean", "description": "Whether to include example requests and responses in the documentation."}, "theme": {"type": "string", "description": "The theme to use for the documentation. Applicable only for 'html' and 'pdf' formats."}, "output_path": {"type": "string", "description": "The local path where the generated documentation should be saved."}}, "required": ["openapi_spec", "output_format"]}, "toolkit_name": "OpenAPIToolkit"}
{"name": "fetch_crypto_historical_data", "description": "Fetch historical price data for a specified cryptocurrency.", "parameters": {"type": "object", "properties": {"symbol": {"type": "string", "description": "The symbol of the cryptocurrency (e.g., BTC, ETH)."}, "start_date": {"type": "string", "description": "The start date for the historical data in YYYY-MM-DD format."}, "end_date": {"type": "string", "description": "The end date for the historical data in YYYY-MM-DD format."}, "interval": {"type": "string", "description": "The interval for the data points (e.g., 1d, 1h, 1m)."}, "exchange": {"type": "string", "description": "The exchange to fetch the data from (e.g., binance, coinbase)."}}, "required": ["symbol", "start_date", "end_date"]}, "toolkit_name": "OpenBBToolkit"}
{"name": "fetch_stock_fundamental_data", "description": "Fetch fundamental data for a given stock, including metrics such as P/E ratio, market cap, dividend yield, and more.", "parameters": {"type": "object", "properties": {"symbol": {"type": "string", "description": "The stock symbol to fetch fundamental data for, e.g., 'AAPL' for Apple Inc."}, "metrics": {"type": "array", "description": "List of specific fundamental metrics to retrieve. If empty, returns all available metrics.", "items": {"type": "string", "description": "The name of the fundamental metric, e.g., 'pe_ratio', 'market_cap'."}}, "period": {"type": "string", "description": "The time period for the data (e.g., 'annual', 'quarterly'). Defaults to 'annual' if not specified."}, "provider": {"type": "string", "description": "The data provider to use for fetching the data. Defaults to the OpenBB default provider if not specified."}}, "required": ["symbol"]}, "toolkit_name": "OpenBBToolkit"}
{"name": "fetch_etf_holdings", "description": "Fetch the holdings data of a specified ETF, including the assets it holds and their respective weights.", "parameters": {"type": "object", "properties": {"symbol": {"type": "string", "description": "The ticker symbol of the ETF (e.g., 'SPY' for SPDR S&P 500 ETF Trust)."}, "date": {"type": "string", "description": "The date for which the holdings data is requested, in YYYY-MM-DD format. If not provided, the most recent data will be fetched."}, "include_weights": {"type": "boolean", "description": "Whether to include the weight of each holding in the ETF. Default is true."}}, "required": ["symbol"]}, "toolkit_name": "OpenBBToolkit"}
{"name": "fetch_economic_indicators", "description": "Fetch economic indicators data such as GDP, unemployment rate, inflation rate, etc.", "parameters": {"type": "object", "properties": {"indicator": {"type": "string", "description": "The name of the economic indicator to fetch (e.g., GDP, unemployment_rate, inflation_rate)."}, "country": {"type": "string", "description": "The country for which the economic indicator data is requested (e.g., USA, China, Germany)."}, "start_date": {"type": "string", "description": "The start date for the data range in YYYY-MM-DD format."}, "end_date": {"type": "string", "description": "The end date for the data range in YYYY-MM-DD format."}, "frequency": {"type": "string", "description": "The frequency of the data (e.g., annual, quarterly, monthly)."}}, "required": ["indicator", "country"]}, "toolkit_name": "OpenBBToolkit"}
{"name": "fetch_cryptocurrency_market_cap", "description": "Fetch the market capitalization data for specified cryptocurrencies.", "parameters": {"type": "object", "properties": {"symbols": {"type": "array", "description": "The cryptocurrency symbols to fetch market cap data for.", "items": {"type": "string", "description": "The symbol of the cryptocurrency (e.g., BTC, ETH)."}}, "currency": {"type": "string", "description": "The currency in which the market cap data should be displayed (e.g., USD, EUR).", "default": "USD"}, "include_24hr_change": {"type": "boolean", "description": "Whether to include the 24-hour percentage change in market cap.", "default": false}}, "required": ["symbols"]}, "toolkit_name": "OpenBBToolkit"}
{"name": "search_pubmed_articles", "description": "Search for articles in PubMed using specified query terms.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to find relevant articles in PubMed."}, "max_results": {"type": "integer", "description": "The maximum number of results to return.", "minimum": 1, "maximum": 100}, "publication_date_range": {"type": "object", "description": "The range of publication dates to filter the search results.", "properties": {"start_date": {"type": "string", "description": "The start date of the publication range in YYYY/MM/DD format."}, "end_date": {"type": "string", "description": "The end date of the publication range in YYYY/MM/DD format."}}}, "article_types": {"type": "array", "description": "The types of articles to include in the search results.", "items": {"type": "string", "description": "The article type, e.g., 'Review', 'Clinical Trial', etc."}}, "sort_by": {"type": "string", "description": "The sorting criteria for the search results.", "enum": ["relevance", "pub_date", "first_author", "last_author", "journal"]}}, "required": ["query"]}, "toolkit_name": "PubMedToolkit"}
{"name": "fetch_pubmed_article_details", "description": "Fetch detailed information for a specific PubMed article using its unique PubMed ID (PMID).", "parameters": {"type": "object", "properties": {"pmid": {"type": "string", "description": "The PubMed ID (PMID) of the article to fetch details for."}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract in the fetched details. Default is true."}, "include_authors": {"type": "boolean", "description": "Whether to include the author list in the fetched details. Default is true."}, "include_references": {"type": "boolean", "description": "Whether to include the list of references in the fetched details. Default is false."}}, "required": ["pmid"]}, "toolkit_name": "PubMedToolkit"}
{"name": "retrieve_pubmed_citations", "description": "Retrieve citations for PubMed articles based on specified criteria such as PMIDs or search terms.", "parameters": {"type": "object", "properties": {"pmids": {"type": "array", "description": "An array of PubMed IDs (PMIDs) for which to retrieve citations.", "items": {"type": "string", "description": "A PubMed ID (PMID)."}}, "search_terms": {"type": "string", "description": "A search query to find relevant PubMed articles and retrieve their citations."}, "max_results": {"type": "integer", "description": "The maximum number of citations to retrieve. Default is 10.", "default": 10}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract in the citation. Default is false.", "default": false}, "sort_by": {"type": "string", "description": "The sorting criteria for the results. Options are 'relevance', 'pub_date', or 'first_author'. Default is 'relevance'.", "enum": ["relevance", "pub_date", "first_author"], "default": "relevance"}}, "required": []}, "toolkit_name": "PubMedToolkit"}
{"name": "fetch_pubmed_related_articles", "description": "Fetch articles related to a specified PubMed article using its unique identifier (PMID).", "parameters": {"type": "object", "properties": {"pmid": {"type": "string", "description": "The PubMed ID (PMID) of the article for which related articles are to be fetched."}, "max_results": {"type": "integer", "description": "The maximum number of related articles to retrieve. Default is 10.", "default": 10}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract of the related articles in the results. Default is false.", "default": false}}, "required": ["pmid"]}, "toolkit_name": "PubMedToolkit"}
{"name": "fetch_pubmed_article_abstracts", "description": "Fetch the abstracts of PubMed articles based on their PubMed IDs (PMIDs).", "parameters": {"type": "object", "properties": {"pmids": {"type": "array", "description": "The PubMed IDs (PMIDs) of the articles whose abstracts are to be fetched.", "items": {"type": "string", "description": "A PubMed ID (PMID) of an article."}}, "format": {"type": "string", "description": "The format in which the abstracts should be returned. Default is 'text'.", "enum": ["text", "html", "xml"], "default": "text"}}, "required": ["pmids"]}, "toolkit_name": "PubMedToolkit"}
{"name": "analyze_sentiment", "description": "Perform sentiment analysis on comments from a Reddit post.", "parameters": {"type": "object", "properties": {"post_id": {"type": "string", "description": "The unique identifier of the Reddit post."}, "comment_limit": {"type": "integer", "description": "The maximum number of comments to analyze. Default is 100.", "default": 100}, "include_replies": {"type": "boolean", "description": "Whether to include replies to comments in the analysis. Default is false.", "default": false}, "output_format": {"type": "string", "description": "The format of the output, either 'summary' or 'detailed'. Default is 'summary'.", "enum": ["summary", "detailed"], "default": "summary"}}, "required": ["post_id"]}, "toolkit_name": "RedditToolkit"}
{"name": "collect_top_posts", "description": "Collect the top posts from a specified subreddit.", "parameters": {"type": "object", "properties": {"subreddit": {"type": "string", "description": "The name of the subreddit to collect top posts from."}, "limit": {"type": "integer", "description": "The maximum number of top posts to collect.", "minimum": 1, "maximum": 100}, "time_filter": {"type": "string", "description": "The time period to filter top posts by (e.g., 'hour', 'day', 'week', 'month', 'year', 'all').", "enum": ["hour", "day", "week", "month", "year", "all"]}, "include_comments": {"type": "boolean", "description": "Whether to include comments for each post in the response."}}, "required": ["subreddit"]}, "toolkit_name": "RedditToolkit"}
{"name": "track_keyword_discussions", "description": "Track discussions on Reddit based on specified keywords.", "parameters": {"type": "object", "properties": {"keywords": {"type": "array", "description": "The keywords to track in Reddit discussions.", "items": {"type": "string", "description": "A keyword to track."}}, "subreddits": {"type": "array", "description": "The subreddits to search for discussions.", "items": {"type": "string", "description": "A subreddit name."}}, "time_range": {"type": "string", "description": "The time range for the search (e.g., 'day', 'week', 'month', 'year', 'all').", "enum": ["day", "week", "month", "year", "all"]}, "limit": {"type": "integer", "description": "The maximum number of discussions to return.", "minimum": 1, "maximum": 100}}, "required": ["keywords"]}, "toolkit_name": "RedditToolkit"}
{"name": "search_subreddits", "description": "Search for subreddits based on a given query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term to find relevant subreddits."}, "limit": {"type": "integer", "description": "The maximum number of subreddits to return.", "minimum": 1, "maximum": 100}, "include_nsfw": {"type": "boolean", "description": "Whether to include NSFW (Not Safe For Work) subreddits in the results.", "default": false}}, "required": ["query"]}, "toolkit_name": "RedditToolkit"}
{"name": "get_user_comments", "description": "Retrieve comments made by a specific Reddit user.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The Reddit username of the user whose comments are to be retrieved."}, "limit": {"type": "integer", "description": "The maximum number of comments to retrieve.", "minimum": 1, "maximum": 100}, "sort": {"type": "string", "description": "The sorting method for the comments. Options: 'new', 'top', 'hot', 'controversial'.", "enum": ["new", "top", "hot", "controversial"]}, "time_filter": {"type": "string", "description": "The time period to filter comments by. Options: 'hour', 'day', 'week', 'month', 'year', 'all'.", "enum": ["hour", "day", "week", "month", "year", "all"]}}, "required": ["username"]}, "toolkit_name": "RedditToolkit"}
{"name": "retrieve_information", "description": "Retrieve information from local vector storage systems based on specified queries.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query string used to retrieve relevant information from the vector storage."}, "top_k": {"type": "integer", "description": "The number of top results to retrieve.", "minimum": 1, "maximum": 100}, "threshold": {"type": "number", "description": "The similarity threshold for filtering results.", "minimum": 0, "maximum": 1}, "include_metadata": {"type": "boolean", "description": "Whether to include metadata in the retrieved results."}, "filters": {"type": "object", "description": "Additional filters to apply to the retrieval query.", "properties": {"source": {"type": "string", "description": "Filter results by source."}, "date_range": {"type": "object", "description": "Filter results by date range.", "properties": {"start": {"type": "string", "format": "date", "description": "The start date of the range."}, "end": {"type": "string", "format": "date", "description": "The end date of the range."}}}}}}, "required": ["query"]}, "toolkit_name": "RetrievalToolkit"}
{"name": "search_documents", "description": "Search for documents in a local vector storage system based on a query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to retrieve relevant documents."}, "top_k": {"type": "integer", "description": "The number of top results to return.", "minimum": 1}, "filter": {"type": "object", "description": "Additional filters to apply to the search, such as metadata constraints.", "properties": {"author": {"type": "string", "description": "Filter documents by author."}, "date_range": {"type": "object", "description": "Filter documents by date range.", "properties": {"start": {"type": "string", "format": "date", "description": "The start date of the range."}, "end": {"type": "string", "format": "date", "description": "The end date of the range."}}}}}}, "required": ["query"]}, "toolkit_name": "RetrievalToolkit"}
{"name": "query_vector_store", "description": "Query a local vector storage system to retrieve relevant information based on specified search criteria.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query used to retrieve relevant information from the vector store."}, "top_k": {"type": "integer", "description": "The number of top results to return from the query."}, "filter": {"type": "object", "description": "Additional filters to apply to the query, such as metadata constraints.", "properties": {"metadata_field": {"type": "string", "description": "The metadata field to filter on."}, "value": {"type": "string", "description": "The value to match in the specified metadata field."}}}, "include_embeddings": {"type": "boolean", "description": "Whether to include the embeddings in the returned results."}}, "required": ["query"]}, "toolkit_name": "RetrievalToolkit"}
{"name": "fetch_similar_documents", "description": "Retrieve documents from a local vector storage system that are similar to the specified query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query string used to retrieve similar documents."}, "top_k": {"type": "integer", "description": "The number of most similar documents to retrieve.", "minimum": 1}, "threshold": {"type": "number", "description": "The similarity threshold for filtering results. Only documents with similarity scores above this threshold will be returned.", "minimum": 0, "maximum": 1}, "include_metadata": {"type": "boolean", "description": "Whether to include metadata with the retrieved documents."}}, "required": ["query"]}, "toolkit_name": "RetrievalToolkit"}
{"name": "retrieve_top_matches", "description": "Retrieve the top matching documents or information from a local vector storage system based on a specified query.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The query string used to retrieve matching documents or information."}, "top_k": {"type": "integer", "description": "The number of top matches to retrieve."}, "threshold": {"type": "number", "description": "The similarity threshold for filtering results. Only matches with a similarity score above this threshold will be returned."}, "include_metadata": {"type": "boolean", "description": "Whether to include metadata with the retrieved documents or information."}, "filters": {"type": "object", "description": "Additional filters to apply to the retrieval query.", "properties": {"source": {"type": "string", "description": "Filter results by source."}, "date_range": {"type": "object", "description": "Filter results by date range.", "properties": {"start": {"type": "string", "description": "The start date of the range."}, "end": {"type": "string", "description": "The end date of the range."}}}}}}, "required": ["query"]}, "toolkit_name": "RetrievalToolkit"}
{"name": "web_search", "description": "Perform a web search using a specified search engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to be executed."}, "search_engine": {"type": "string", "description": "The search engine to use for the query. Options include Google, DuckDuckGo, Wikipedia, Bing, Baidu, and Wolfram Alpha.", "enum": ["Google", "DuckDuckGo", "Wikipedia", "Bing", "Baidu", "Wolfram Alpha"]}, "max_results": {"type": "integer", "description": "The maximum number of search results to return.", "minimum": 1, "maximum": 50}, "include_metadata": {"type": "boolean", "description": "Whether to include metadata (e.g., titles, URLs, snippets) in the search results."}}, "required": ["query", "search_engine"]}, "toolkit_name": "SearchToolkit"}
{"name": "search_wikipedia", "description": "Perform a search on Wikipedia and retrieve relevant articles or information.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search term or phrase to look up on Wikipedia."}, "language": {"type": "string", "description": "The language version of Wikipedia to search (e.g., 'en' for English, 'fr' for French). Default is 'en'."}, "limit": {"type": "integer", "description": "The maximum number of results to return. Default is 5."}, "summary_only": {"type": "boolean", "description": "If true, returns only the summary of the articles. If false, returns full article details. Default is true."}}, "required": ["query"]}, "toolkit_name": "SearchToolkit"}
{"name": "search_wolfram_alpha", "description": "Perform a search using Wolfram Alpha computational knowledge engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to be processed by Wolfram Alpha."}, "assumptions": {"type": "array", "description": "List of assumptions for the query.", "items": {"type": "string", "description": "An assumption to be considered in the search."}}, "format": {"type": "string", "description": "The desired format of the response (e.g., plaintext, image, HTML).", "enum": ["plaintext", "image", "HTML"]}, "timeout": {"type": "integer", "description": "The maximum time in seconds to wait for a response."}}, "required": ["query"]}, "toolkit_name": "SearchToolkit"}
{"name": "search_duckduckgo", "description": "Perform a web search using DuckDuckGo search engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to be performed on DuckDuckGo."}, "max_results": {"type": "integer", "description": "The maximum number of search results to return."}, "safe_search": {"type": "boolean", "description": "Whether to enable safe search filtering."}, "region": {"type": "string", "description": "The region to use for the search (e.g., 'us-en', 'uk-en')."}}, "required": ["query"]}, "toolkit_name": "SearchToolkit"}
{"name": "search_bing", "description": "Perform a web search using the Bing search engine.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to be performed on Bing."}, "num_results": {"type": "integer", "description": "The number of search results to return.", "minimum": 1, "maximum": 50}, "safe_search": {"type": "boolean", "description": "Whether to enable safe search to filter out adult content."}, "region": {"type": "string", "description": "The region code to tailor the search results (e.g., 'en-US', 'zh-CN')."}}, "required": ["query"]}, "toolkit_name": "SearchToolkit"}
{"name": "search_papers", "description": "Search for academic papers using the Semantic Scholar API based on specified criteria.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query to find relevant papers."}, "limit": {"type": "integer", "description": "The maximum number of papers to return."}, "fields": {"type": "array", "description": "The fields to include in the search results.", "items": {"type": "string", "description": "The field name to include (e.g., title, authors, abstract)."}}, "year_range": {"type": "object", "description": "The range of publication years to filter the search results.", "properties": {"start": {"type": "integer", "description": "The starting year of the range."}, "end": {"type": "integer", "description": "The ending year of the range."}}}, "publication_types": {"type": "array", "description": "The types of publications to include in the search results.", "items": {"type": "string", "description": "The publication type (e.g., JournalArticle, ConferencePaper)."}}}, "required": ["query"]}, "toolkit_name": "SemanticScholarToolkit"}
{"name": "get_author_details", "description": "Fetch detailed information about an author from the Semantic Scholar API using their author ID.", "parameters": {"type": "object", "properties": {"author_id": {"type": "string", "description": "The unique identifier of the author in the Semantic Scholar database."}, "include_papers": {"type": "boolean", "description": "Whether to include the list of papers authored by the author in the response.", "default": false}}, "required": ["author_id"]}, "toolkit_name": "SemanticScholarToolkit"}
{"name": "get_paper_details", "description": "Fetch detailed information about a specific academic paper from the Semantic Scholar database.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The unique identifier of the paper in the Semantic Scholar database."}, "include_abstract": {"type": "boolean", "description": "Whether to include the abstract of the paper in the response. Default is true."}, "include_citations": {"type": "boolean", "description": "Whether to include the list of citations for the paper in the response. Default is false."}, "include_references": {"type": "boolean", "description": "Whether to include the list of references for the paper in the response. Default is false."}}, "required": ["paper_id"]}, "toolkit_name": "SemanticScholarToolkit"}
{"name": "get_paper_citations", "description": "Fetch the list of papers that cite a specified paper from Semantic Scholar.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The Semantic Scholar ID of the paper for which citations are to be retrieved."}, "limit": {"type": "integer", "description": "The maximum number of citation records to return.", "minimum": 1, "maximum": 100}, "offset": {"type": "integer", "description": "The number of citation records to skip before starting to return results.", "minimum": 0}, "fields": {"type": "array", "description": "The specific fields to include in each citation record.", "items": {"type": "string", "description": "The field name to include (e.g., 'title', 'authors', 'year')."}}}, "required": ["paper_id"]}, "toolkit_name": "SemanticScholarToolkit"}
{"name": "get_paper_references", "description": "Fetch the references of a specific paper from the Semantic Scholar database.", "parameters": {"type": "object", "properties": {"paper_id": {"type": "string", "description": "The unique identifier of the paper in the Semantic Scholar database."}, "limit": {"type": "integer", "description": "The maximum number of references to return. Default is 10.", "default": 10}, "offset": {"type": "integer", "description": "The number of references to skip before starting to return results. Default is 0.", "default": 0}}, "required": ["paper_id"]}, "toolkit_name": "SemanticScholarToolkit"}
{"name": "invite_to_channel", "description": "Invite users to a Slack channel.", "parameters": {"type": "object", "properties": {"channel_id": {"type": "string", "description": "The ID of the channel to which users will be invited."}, "user_ids": {"type": "array", "description": "The list of user IDs to invite to the channel.", "items": {"type": "string", "description": "The ID of the user to invite."}}}, "required": ["channel_id", "user_ids"]}, "toolkit_name": "SlackToolkit"}
{"name": "create_channel", "description": "Create a new channel in Slack.", "parameters": {"type": "object", "properties": {"channel_name": {"type": "string", "description": "The name of the channel to be created."}, "is_private": {"type": "boolean", "description": "Whether the channel should be private (true) or public (false)."}, "description": {"type": "string", "description": "A brief description of the channel."}, "users_to_invite": {"type": "array", "description": "List of user IDs to invite to the channel upon creation.", "items": {"type": "string", "description": "The user ID to invite to the channel."}}}, "required": ["channel_name"]}, "toolkit_name": "SlackToolkit"}
{"name": "leave_channel", "description": "Leave a Slack channel.", "parameters": {"type": "object", "properties": {"channel_id": {"type": "string", "description": "The ID of the channel to leave."}, "user_id": {"type": "string", "description": "The ID of the user leaving the channel."}}, "required": ["channel_id", "user_id"]}, "toolkit_name": "SlackToolkit"}
{"name": "join_channel", "description": "Join an existing Slack channel.", "parameters": {"type": "object", "properties": {"channel_name": {"type": "string", "description": "The name of the channel to join."}, "user_id": {"type": "string", "description": "The ID of the user who wants to join the channel."}}, "required": ["channel_name", "user_id"]}, "toolkit_name": "SlackToolkit"}
{"name": "set_channel_topic", "description": "Set the topic for a specific Slack channel.", "parameters": {"type": "object", "properties": {"channel_id": {"type": "string", "description": "The ID of the channel to set the topic for."}, "topic": {"type": "string", "description": "The new topic to set for the channel."}}, "required": ["channel_id", "topic"]}, "toolkit_name": "SlackToolkit"}
{"name": "create_payment_intent", "description": "Create a PaymentIntent to initiate a payment process via Stripe.", "parameters": {"type": "object", "properties": {"amount": {"type": "integer", "description": "The amount to be charged, in the smallest currency unit (e.g., cents for USD)."}, "currency": {"type": "string", "description": "The currency in which the payment will be processed (e.g., 'usd', 'eur')."}, "customer_id": {"type": "string", "description": "The Stripe customer ID associated with the payment."}, "payment_method_types": {"type": "array", "description": "The list of payment method types allowed for this PaymentIntent.", "items": {"type": "string", "description": "A payment method type (e.g., 'card', 'bank_transfer')."}}, "metadata": {"type": "object", "description": "Additional metadata associated with the PaymentIntent."}, "description": {"type": "string", "description": "An optional description for the PaymentIntent."}}, "required": ["amount", "currency"]}, "toolkit_name": "StripeToolkit"}
{"name": "retrieve_payment_details", "description": "Retrieve the details of a specific payment transaction processed via Stripe.", "parameters": {"type": "object", "properties": {"payment_intent_id": {"type": "string", "description": "The unique identifier of the payment intent to retrieve details for."}, "expand": {"type": "array", "description": "Specifies which fields in the response should be expanded.", "items": {"type": "string", "description": "The field to expand in the response."}}}, "required": ["payment_intent_id"]}, "toolkit_name": "StripeToolkit"}
{"name": "create_customer", "description": "Create a new customer in Stripe for managing payments and subscriptions.", "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The customer's full name."}, "email": {"type": "string", "description": "The customer's email address."}, "phone": {"type": "string", "description": "The customer's phone number."}, "address": {"type": "object", "description": "The customer's address.", "properties": {"line1": {"type": "string", "description": "Address line 1."}, "line2": {"type": "string", "description": "Address line 2."}, "city": {"type": "string", "description": "City or locality."}, "state": {"type": "string", "description": "State or province."}, "postal_code": {"type": "string", "description": "Postal or ZIP code."}, "country": {"type": "string", "description": "Two-letter country code."}}}, "metadata": {"type": "object", "description": "Additional metadata about the customer in key-value pairs."}}, "required": ["name", "email"]}, "toolkit_name": "StripeToolkit"}
{"name": "create_refund", "description": "Create a refund for a specific payment intent.", "parameters": {"type": "object", "properties": {"payment_intent_id": {"type": "string", "description": "The ID of the payment intent to be refunded."}, "amount": {"type": "integer", "description": "The amount to refund, in the smallest currency unit (e.g., cents for USD)."}, "reason": {"type": "string", "description": "The reason for the refund (e.g., 'duplicate', 'fraudulent', 'requested_by_customer').", "enum": ["duplicate", "fraudulent", "requested_by_customer"]}, "metadata": {"type": "object", "description": "Additional metadata to attach to the refund."}}, "required": ["payment_intent_id"]}, "toolkit_name": "StripeToolkit"}
{"name": "create_subscription", "description": "Create a subscription for a customer to a specified plan.", "parameters": {"type": "object", "properties": {"customer_id": {"type": "string", "description": "The ID of the customer who is subscribing."}, "plan_id": {"type": "string", "description": "The ID of the plan the customer is subscribing to."}, "billing_cycle_anchor": {"type": "integer", "description": "The timestamp at which to start the subscription billing cycle."}, "prorate": {"type": "boolean", "description": "Whether to prorate the subscription if it starts mid-billing cycle."}, "default_payment_method": {"type": "string", "description": "The ID of the default payment method for the subscription."}, "metadata": {"type": "object", "description": "Additional metadata about the subscription.", "properties": {}}}, "required": ["customer_id", "plan_id"]}, "toolkit_name": "StripeToolkit"}
{"name": "solve_equation", "description": "Solve a symbolic equation or system of equations using SymPy.", "parameters": {"type": "object", "properties": {"equation": {"type": "string", "description": "The equation or system of equations to solve, represented as a string."}, "variables": {"type": "array", "description": "The variables to solve for.", "items": {"type": "string", "description": "The variable name as a string."}}, "domain": {"type": "string", "description": "The domain in which to find solutions (e.g., 'real', 'complex'). Default is 'complex'."}}, "required": ["equation", "variables"]}, "toolkit_name": "SymPyToolkit"}
{"name": "differentiate_function", "description": "Compute the derivative of a given mathematical function with respect to a specified variable.", "parameters": {"type": "object", "properties": {"function": {"type": "string", "description": "The mathematical function to differentiate, expressed as a string (e.g., 'x**2 + 3*x + 1')."}, "variable": {"type": "string", "description": "The variable with respect to which the function is differentiated (e.g., 'x')."}, "order": {"type": "integer", "description": "The order of the derivative (e.g., 1 for first derivative, 2 for second derivative). Default is 1.", "default": 1}}, "required": ["function", "variable"]}, "toolkit_name": "SymPyToolkit"}
{"name": "integrate_function", "description": "Compute the integral of a given mathematical function using SymPy.", "parameters": {"type": "object", "properties": {"function": {"type": "string", "description": "The mathematical function to integrate, expressed as a string (e.g., 'x**2 + 3*x + 1')."}, "variable": {"type": "string", "description": "The variable with respect to which the integration is performed (e.g., 'x')."}, "lower_limit": {"type": "number", "description": "The lower limit of the definite integral. If not provided, the integral is indefinite."}, "upper_limit": {"type": "number", "description": "The upper limit of the definite integral. If not provided, the integral is indefinite."}}, "required": ["function", "variable"]}, "toolkit_name": "SymPyToolkit"}
{"name": "matrix_operations", "description": "Perform various matrix operations such as determinant, inverse, and multiplication using SymPy.", "parameters": {"type": "object", "properties": {"operation": {"type": "string", "description": "The matrix operation to perform. Must be one of ['determinant', 'inverse', 'multiply']."}, "matrix1": {"type": "array", "description": "The first matrix represented as a 2D array.", "items": {"type": "array", "description": "A row of the matrix.", "items": {"type": "number", "description": "An element of the matrix."}}}, "matrix2": {"type": "array", "description": "The second matrix represented as a 2D array (required only for multiplication).", "items": {"type": "array", "description": "A row of the matrix.", "items": {"type": "number", "description": "An element of the matrix."}}}}, "required": ["operation", "matrix1"]}, "toolkit_name": "SymPyToolkit"}
{"name": "simplify_expression", "description": "Simplify a mathematical expression using SymPy's simplification functions.", "parameters": {"type": "object", "properties": {"expression": {"type": "string", "description": "The mathematical expression to be simplified."}, "method": {"type": "string", "description": "The simplification method to use (e.g., 'simplify', 'expand', 'factor', 'trigsimp').", "enum": ["simplify", "expand", "factor", "trigsimp", "cancel", "collect"]}, "variables": {"type": "array", "description": "List of variables in the expression.", "items": {"type": "string", "description": "A variable in the expression."}}}, "required": ["expression"]}, "toolkit_name": "SymPyToolkit"}
{"name": "execute_shell_command", "description": "Execute a shell command in the terminal and return the output.", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to be executed."}, "working_directory": {"type": "string", "description": "The working directory where the command will be executed. Defaults to the current directory if not specified."}, "timeout": {"type": "integer", "description": "The maximum time in seconds to wait for the command to complete. Defaults to no timeout if not specified."}, "environment_variables": {"type": "object", "description": "A dictionary of environment variables to set for the command execution.", "additionalProperties": {"type": "string", "description": "The value of the environment variable."}}}, "required": ["command"]}, "toolkit_name": "TerminalToolkit"}
{"name": "search_files", "description": "Search for files by name or content within a specified directory.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory path to search within."}, "name_pattern": {"type": "string", "description": "The pattern to match file names against. Supports wildcards."}, "content_pattern": {"type": "string", "description": "The pattern to match file content against. Leave empty to skip content search."}, "recursive": {"type": "boolean", "description": "Whether to search recursively in subdirectories. Default is false."}, "case_sensitive": {"type": "boolean", "description": "Whether the search is case sensitive. Default is false."}}, "required": ["directory"]}, "toolkit_name": "TerminalToolkit"}
{"name": "manage_terminal_sessions", "description": "Manage terminal sessions across multiple operating systems, including creating, listing, and terminating sessions.", "parameters": {"type": "object", "properties": {"action": {"type": "string", "description": "The action to perform on the terminal session. Possible values: 'create', 'list', 'terminate'.", "enum": ["create", "list", "terminate"]}, "session_id": {"type": "string", "description": "The ID of the terminal session to terminate. Required if action is 'terminate'."}, "session_name": {"type": "string", "description": "The name of the new terminal session. Required if action is 'create'."}, "operating_system": {"type": "string", "description": "The operating system for the new terminal session. Required if action is 'create'.", "enum": ["linux", "macos", "windows"]}}, "required": ["action"]}, "toolkit_name": "TerminalToolkit"}
{"name": "monitor_processes", "description": "Monitor running processes on the system, including their resource usage and status.", "parameters": {"type": "object", "properties": {"process_name": {"type": "string", "description": "The name of the process to monitor. If not specified, all processes will be monitored."}, "sort_by": {"type": "string", "description": "The criteria to sort the processes by. Options include 'cpu_usage', 'memory_usage', 'process_id', or 'name'.", "enum": ["cpu_usage", "memory_usage", "process_id", "name"]}, "max_results": {"type": "integer", "description": "The maximum number of processes to return. If not specified, all matching processes will be returned."}, "refresh_interval": {"type": "number", "description": "The interval in seconds at which to refresh the process information. If not specified, the information will be fetched once."}}, "required": []}, "toolkit_name": "TerminalToolkit"}
{"name": "find_and_replace_in_files", "description": "Search for files containing specific text and replace it with new text.", "parameters": {"type": "object", "properties": {"directory": {"type": "string", "description": "The directory path to search for files."}, "search_text": {"type": "string", "description": "The text to search for in the files."}, "replace_text": {"type": "string", "description": "The text to replace the found search text with."}, "file_pattern": {"type": "string", "description": "The file pattern to match (e.g., '*.txt'). If not specified, all files will be considered."}, "recursive": {"type": "boolean", "description": "Whether to search recursively in subdirectories. Default is false."}, "case_sensitive": {"type": "boolean", "description": "Whether the search should be case sensitive. Default is false."}}, "required": ["directory", "search_text", "replace_text"]}, "toolkit_name": "TerminalToolkit"}
{"name": "retrieve_user_profile", "description": "Retrieve the profile information of a specified Twitter user.", "parameters": {"type": "object", "properties": {"username": {"type": "string", "description": "The username of the Twitter user whose profile information is to be retrieved."}, "include_tweets": {"type": "boolean", "description": "Whether to include the user's recent tweets in the profile information. Default is false."}, "tweet_count": {"type": "integer", "description": "The number of recent tweets to include if include_tweets is true. Default is 5."}}, "required": ["username"]}, "toolkit_name": "TwitterToolkit"}
{"name": "create_tweet", "description": "Create and post a new tweet on Twitter.", "parameters": {"type": "object", "properties": {"content": {"type": "string", "description": "The text content of the tweet."}, "media_paths": {"type": "array", "description": "List of local paths to media files (images or videos) to attach to the tweet.", "items": {"type": "string", "description": "The local path of the media file."}}, "reply_to_tweet_id": {"type": "string", "description": "The ID of the tweet this tweet is replying to, if applicable."}, "sensitive": {"type": "boolean", "description": "Whether the tweet contains sensitive content."}}, "required": ["content"]}, "toolkit_name": "TwitterToolkit"}
{"name": "delete_tweet", "description": "Delete a specific tweet from the user's Twitter account.", "parameters": {"type": "object", "properties": {"tweet_id": {"type": "string", "description": "The unique identifier of the tweet to be deleted."}}, "required": ["tweet_id"]}, "toolkit_name": "TwitterToolkit"}
{"name": "search_tweets", "description": "Search for tweets based on a query string.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "The search query string to find tweets."}, "max_results": {"type": "integer", "description": "The maximum number of tweets to return."}, "include_retweets": {"type": "boolean", "description": "Whether to include retweets in the search results."}, "filter_by_media": {"type": "boolean", "description": "Whether to filter tweets to only those with media (photos, videos, etc.)."}, "language": {"type": "string", "description": "The language of the tweets to search for (e.g., 'en' for English)."}}, "required": ["query"]}, "toolkit_name": "TwitterToolkit"}
{"name": "like_tweet", "description": "Like a tweet on Twitter.", "parameters": {"type": "object", "properties": {"tweet_id": {"type": "string", "description": "The ID of the tweet to like."}, "user_id": {"type": "string", "description": "The ID of the user who is liking the tweet."}}, "required": ["tweet_id", "user_id"]}, "toolkit_name": "TwitterToolkit"}
{"name": "extract_key_frames", "description": "Extract key frames from a video for further analysis.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video file."}, "frame_interval": {"type": "integer", "description": "The interval between extracted frames in seconds. If not specified, key frames will be extracted based on scene changes."}, "output_format": {"type": "string", "description": "The format of the extracted frames (e.g., 'jpg', 'png'). Default is 'jpg'."}, "output_directory": {"type": "string", "description": "The directory where extracted frames will be saved. If not specified, frames will be saved in the current directory."}}, "required": ["video_path"]}, "toolkit_name": "VideoAnalysisToolkit"}
{"name": "answer_video_questions", "description": "Answer questions about the content of a video using vision-language models.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video file to be analyzed."}, "questions": {"type": "array", "description": "A list of questions about the video content.", "items": {"type": "string", "description": "A question about the video content."}}, "model": {"type": "string", "description": "The vision-language model to be used for answering the questions.", "enum": ["CLIP", "BLIP", "ViLBERT", "Other"]}, "frame_interval": {"type": "integer", "description": "The interval (in seconds) between frames to be analyzed. If not specified, key frames will be used.", "default": 0}}, "required": ["video_path", "questions"]}, "toolkit_name": "VideoAnalysisToolkit"}
{"name": "detect_objects_in_video", "description": "Detects and identifies objects in a video using a vision-language model.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video file to analyze."}, "frame_interval": {"type": "integer", "description": "The interval between frames to analyze. A lower value means more frames will be processed.", "minimum": 1, "default": 10}, "confidence_threshold": {"type": "number", "description": "The minimum confidence score (between 0 and 1) for an object detection to be considered valid.", "minimum": 0, "maximum": 1, "default": 0.7}, "object_categories": {"type": "array", "description": "A list of object categories to detect. If empty, all detectable categories will be included.", "items": {"type": "string", "description": "The name of an object category (e.g., 'person', 'car', 'dog')."}, "default": []}, "output_format": {"type": "string", "description": "The format of the output results. Options: 'json' or 'csv'.", "enum": ["json", "csv"], "default": "json"}}, "required": ["video_path"]}, "toolkit_name": "VideoAnalysisToolkit"}
{"name": "generate_video_summary", "description": "Generate a summary of the video content by analyzing key frames and extracting important information.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video file to be analyzed."}, "summary_length": {"type": "integer", "description": "The desired length of the summary in sentences.", "minimum": 1, "maximum": 10}, "include_timestamps": {"type": "boolean", "description": "Whether to include timestamps for key events in the summary.", "default": false}, "language": {"type": "string", "description": "The language in which the summary should be generated.", "default": "en"}}, "required": ["video_path"]}, "toolkit_name": "VideoAnalysisToolkit"}
{"name": "analyze_video_scenes", "description": "Analyze and segment a video into different scenes based on visual and contextual changes.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video file to be analyzed."}, "sensitivity": {"type": "number", "description": "The sensitivity threshold for detecting scene changes (lower values detect more subtle changes).", "minimum": 0, "maximum": 1}, "min_scene_duration": {"type": "number", "description": "The minimum duration (in seconds) for a segment to be considered a scene.", "minimum": 0}, "output_format": {"type": "string", "description": "The format of the output (e.g., 'json', 'csv').", "enum": ["json", "csv"]}}, "required": ["video_path"]}, "toolkit_name": "VideoAnalysisToolkit"}
{"name": "download_video", "description": "Download a video from a specified URL, with options to split it into chunks.", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "The URL of the video to download."}, "output_path": {"type": "string", "description": "The local path where the downloaded video will be saved."}, "split_into_chunks": {"type": "boolean", "description": "Whether to split the video into chunks. Default is false."}, "chunk_duration": {"type": "integer", "description": "The duration of each chunk in seconds. Required if split_into_chunks is true."}, "format": {"type": "string", "description": "The desired video format (e.g., mp4, avi). Default is mp4."}, "quality": {"type": "string", "description": "The desired video quality (e.g., 720p, 1080p)."}}, "required": ["url", "output_path"]}, "toolkit_name": "VideoDownloaderToolkit"}
{"name": "split_video", "description": "Split a downloaded video into smaller chunks based on specified criteria.", "parameters": {"type": "object", "properties": {"video_path": {"type": "string", "description": "The local path or URL of the video to be split."}, "chunk_duration": {"type": "integer", "description": "The duration of each chunk in seconds."}, "output_directory": {"type": "string", "description": "The directory where the split video chunks will be saved."}, "format": {"type": "string", "description": "The output format of the video chunks (e.g., mp4, avi)."}, "overwrite": {"type": "boolean", "description": "Whether to overwrite existing files in the output directory."}}, "required": ["video_path", "chunk_duration", "output_directory"]}, "toolkit_name": "VideoDownloaderToolkit"}
{"name": "get_video_info", "description": "Retrieve information about a video from a specified URL, including duration, resolution, and available formats.", "parameters": {"type": "object", "properties": {"video_url": {"type": "string", "description": "The URL of the video to retrieve information from."}, "include_formats": {"type": "boolean", "description": "Whether to include available formats in the response. Default is false."}}, "required": ["video_url"]}, "toolkit_name": "VideoDownloaderToolkit"}
{"name": "convert_video_format", "description": "Convert a downloaded video file to a different format.", "parameters": {"type": "object", "properties": {"input_path": {"type": "string", "description": "The local path of the video file to be converted."}, "output_format": {"type": "string", "description": "The desired output format of the video (e.g., mp4, avi, mov)."}, "output_path": {"type": "string", "description": "The local path where the converted video will be saved."}, "quality": {"type": "integer", "description": "The quality of the output video (1-100).", "minimum": 1, "maximum": 100}, "keep_original": {"type": "boolean", "description": "Whether to keep the original video file after conversion."}}, "required": ["input_path", "output_format"]}, "toolkit_name": "VideoDownloaderToolkit"}
{"name": "download_video_playlist", "description": "Download a playlist of videos from a supported video service.", "parameters": {"type": "object", "properties": {"playlist_url": {"type": "string", "description": "The URL of the video playlist to download."}, "output_directory": {"type": "string", "description": "The local directory where the downloaded videos will be saved."}, "max_videos": {"type": "integer", "description": "The maximum number of videos to download from the playlist. If not specified, all videos will be downloaded."}, "split_into_chunks": {"type": "boolean", "description": "Whether to split each downloaded video into chunks. Default is false."}, "chunk_duration": {"type": "number", "description": "The duration of each chunk in seconds, if splitting is enabled."}, "format": {"type": "string", "description": "The desired video format for the downloaded videos (e.g., mp4, avi)."}}, "required": ["playlist_url", "output_directory"]}, "toolkit_name": "VideoDownloaderToolkit"}
{"name": "get_weather_forecast", "description": "Fetch the weather forecast for a specific city using the OpenWeatherMap API.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The name of the city for which the weather forecast is requested."}, "country_code": {"type": "string", "description": "The country code of the city (e.g., 'US' for United States)."}, "days": {"type": "integer", "description": "The number of days for the weather forecast (max 7 days)."}, "units": {"type": "string", "description": "The unit system for the weather data (e.g., 'metric' for Celsius, 'imperial' for Fahrenheit).", "enum": ["metric", "imperial", "standard"]}}, "required": ["city"]}, "toolkit_name": "WeatherToolkit"}
{"name": "get_current_weather", "description": "Fetch the current weather data for a specified city using the OpenWeatherMap API.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The name of the city for which to fetch the current weather data."}, "country_code": {"type": "string", "description": "The country code of the city (e.g., 'US' for United States)."}, "units": {"type": "string", "description": "The unit system for the weather data (e.g., 'metric' for Celsius, 'imperial' for Fahrenheit).", "enum": ["metric", "imperial", "standard"]}, "language": {"type": "string", "description": "The language for the weather description (e.g., 'en' for English, 'fr' for French)."}}, "required": ["city"]}, "toolkit_name": "WeatherToolkit"}
{"name": "get_weather_history", "description": "Fetch historical weather data for a specific city using the OpenWeatherMap API.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The name of the city for which historical weather data is requested."}, "country_code": {"type": "string", "description": "The country code of the city (e.g., 'US' for United States)."}, "start_date": {"type": "string", "description": "The start date for the historical data in 'YYYY-MM-DD' format."}, "end_date": {"type": "string", "description": "The end date for the historical data in 'YYYY-MM-DD' format."}, "units": {"type": "string", "description": "The unit system for the weather data ('metric' for Celsius, 'imperial' for Fahrenheit).", "enum": ["metric", "imperial"]}}, "required": ["city", "start_date", "end_date"]}, "toolkit_name": "WeatherToolkit"}
{"name": "get_air_quality", "description": "Fetch the air quality index (AQI) and related pollutant data for a specific city using the OpenWeatherMap API.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The name of the city for which to fetch air quality data."}, "country_code": {"type": "string", "description": "The country code of the city (e.g., 'US' for United States)."}, "state_code": {"type": "string", "description": "The state code of the city, if applicable (e.g., 'CA' for California)."}, "include_pollutants": {"type": "boolean", "description": "Whether to include detailed pollutant data in the response. Default is false."}}, "required": ["city"]}, "toolkit_name": "WeatherToolkit"}
{"name": "get_weather_alerts", "description": "Fetch weather alerts for a specific city using the OpenWeatherMap API.", "parameters": {"type": "object", "properties": {"city": {"type": "string", "description": "The name of the city for which weather alerts are to be fetched."}, "country_code": {"type": "string", "description": "The country code of the city (e.g., 'US' for United States)."}, "language": {"type": "string", "description": "The language in which the alerts should be returned (e.g., 'en' for English).", "default": "en"}}, "required": ["city"]}, "toolkit_name": "WeatherToolkit"}
{"name": "create_message_template", "description": "Create a message template for WhatsApp Business API to use in notifications or marketing messages.", "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the message template."}, "language": {"type": "string", "description": "The language code of the template (e.g., 'en' for English)."}, "category": {"type": "string", "description": "The category of the template (e.g., 'MARKETING', 'UTILITY', 'AUTHENTICATION')."}, "components": {"type": "array", "description": "The components of the template including text, buttons, etc.", "items": {"type": "object", "properties": {"type": {"type": "string", "description": "The type of the component (e.g., 'HEADER', 'BODY', 'FOOTER', 'BUTTONS')."}, "text": {"type": "string", "description": "The text content of the component."}, "buttons": {"type": "array", "description": "The buttons included in the component.", "items": {"type": "object", "properties": {"type": {"type": "string", "description": "The type of the button (e.g., 'QUICK_REPLY', 'URL')."}, "text": {"type": "string", "description": "The text displayed on the button."}, "url": {"type": "string", "description": "The URL for 'URL' type buttons."}}}}}}}}, "required": ["name", "language", "category", "components"]}, "toolkit_name": "WhatsAppToolkit"}
{"name": "send_whatsapp_message", "description": "Send a WhatsApp message to a recipient using the WhatsApp Business API.", "parameters": {"type": "object", "properties": {"recipient_phone_number": {"type": "string", "description": "The phone number of the recipient in international format (e.g., +1234567890)."}, "message_content": {"type": "string", "description": "The content of the message to be sent."}, "message_type": {"type": "string", "description": "The type of the message (e.g., 'text', 'image', 'document', 'video').", "enum": ["text", "image", "document", "video"]}, "media_url": {"type": "string", "description": "The URL of the media file to be sent if the message type is not 'text'."}, "preview_url": {"type": "boolean", "description": "Whether to include a preview for links in the message (only applicable for text messages with URLs).", "default": false}}, "required": ["recipient_phone_number", "message_content", "message_type"]}, "toolkit_name": "WhatsAppToolkit"}
{"name": "get_business_profile", "description": "Retrieve the business profile information associated with the WhatsApp Business API account.", "parameters": {"type": "object", "properties": {"business_id": {"type": "string", "description": "The unique identifier of the business account."}, "fields": {"type": "array", "description": "The specific fields of the business profile to retrieve.", "items": {"type": "string", "description": "The field name, e.g., 'about', 'email', 'address', etc."}}}, "required": ["business_id"]}, "toolkit_name": "WhatsAppToolkit"}
{"name": "delete_message_template", "description": "Delete a message template from the WhatsApp Business API.", "parameters": {"type": "object", "properties": {"template_name": {"type": "string", "description": "The name of the message template to be deleted."}, "language": {"type": "string", "description": "The language code of the template (e.g., 'en_US')."}}, "required": ["template_name", "language"]}, "toolkit_name": "WhatsAppToolkit"}
{"name": "update_business_profile", "description": "Update the business profile information on WhatsApp Business API.", "parameters": {"type": "object", "properties": {"about": {"type": "string", "description": "The description of the business."}, "address": {"type": "string", "description": "The physical address of the business."}, "email": {"type": "string", "description": "The contact email of the business."}, "website": {"type": "array", "description": "The website URL(s) of the business.", "items": {"type": "string", "description": "A website URL"}}, "profile_picture_url": {"type": "string", "description": "The URL of the business profile picture."}}, "required": []}, "toolkit_name": "WhatsAppToolkit"}
{"name": "execute_zapier_action", "description": "Execute a predefined Zapier action through natural language commands to automate workflows.", "parameters": {"type": "object", "properties": {"action_id": {"type": "string", "description": "The unique identifier of the Zapier action to be executed."}, "input_data": {"type": "object", "description": "The input data required for the Zapier action, provided as key-value pairs.", "additionalProperties": {"type": "string", "description": "The value for the corresponding input field in the Zapier action."}}, "instructions": {"type": "string", "description": "Natural language instructions describing the action to be performed, used by Zapier's NLA API to interpret the command."}}, "required": ["action_id", "instructions"]}, "toolkit_name": "ZapierToolkit"}
{"name": "list_zapier_actions", "description": "List all available Zapier actions that can be executed through the NLA API.", "parameters": {"type": "object", "properties": {"filter": {"type": "string", "description": "A keyword to filter the list of actions by name or description."}, "limit": {"type": "integer", "description": "The maximum number of actions to return."}}, "required": []}, "toolkit_name": "ZapierToolkit"}
{"name": "search_zapier_triggers", "description": "Search for available triggers in Zapier that can be used to start workflows based on specific events.", "parameters": {"type": "object", "properties": {"app_name": {"type": "string", "description": "The name of the app for which to search triggers."}, "trigger_keyword": {"type": "string", "description": "A keyword to filter the triggers by name or description."}, "limit": {"type": "integer", "description": "The maximum number of triggers to return."}}, "required": []}, "toolkit_name": "ZapierToolkit"}
{"name": "get_zapier_action_details", "description": "Retrieve detailed information about a specific Zapier action, including its parameters and configuration options.", "parameters": {"type": "object", "properties": {"action_id": {"type": "string", "description": "The unique identifier of the Zapier action."}, "include_parameters": {"type": "boolean", "description": "Whether to include detailed parameter information for the action.", "default": false}, "include_examples": {"type": "boolean", "description": "Whether to include example usage scenarios for the action.", "default": false}}, "required": ["action_id"]}, "toolkit_name": "ZapierToolkit"}
{"name": "create_zapier_zap", "description": "Create a new Zap in Zapier to automate workflows between different apps.", "parameters": {"type": "object", "properties": {"trigger_app": {"type": "string", "description": "The name of the app that will trigger the Zap."}, "trigger_event": {"type": "string", "description": "The specific event in the trigger app that will start the Zap."}, "action_app": {"type": "string", "description": "The name of the app that will perform the action in response to the trigger."}, "action_event": {"type": "string", "description": "The specific event in the action app that will be executed."}, "trigger_fields": {"type": "object", "description": "The fields required for the trigger event, specified as key-value pairs."}, "action_fields": {"type": "object", "description": "The fields required for the action event, specified as key-value pairs."}, "zap_name": {"type": "string", "description": "The name of the Zap to be created."}, "is_active": {"type": "boolean", "description": "Whether the Zap should be active immediately after creation."}}, "required": ["trigger_app", "trigger_event", "action_app", "action_event", "zap_name"]}, "toolkit_name": "ZapierToolkit"}
